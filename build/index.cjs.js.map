{"version":3,"file":"index.cjs.js","sources":["../../woby/dist/use_microtask-e694cf95.js","../../woby/dist/wrap_clone_element-e197fd42.js","../../woby/dist/setters-3e914440.js","../../woby/dist/jsx-runtime-742b912a.js","../src/utils.ts","../../woby/dist/htm.module-aa8e56d7.js","../../woby/dist/render_to_string-0e4682a5.js","../../woby/dist/index.es.js","../src/Wheel.tsx","../src/WheelPicker.tsx","../index.tsx"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst SYMBOL_OBSERVABLE = Symbol(\"Observable\");\nconst SYMBOL_OBSERVABLE_FROZEN = Symbol(\"Frozen\");\nconst SYMBOL_OBSERVABLE_READABLE = Symbol(\"Readable\");\nconst SYMBOL_OBSERVABLE_WRITABLE = Symbol(\"Writable\");\nconst SYMBOL_STORE = Symbol(\"Store\");\nconst SYMBOL_STORE_KEYS = Symbol(\"Keys\");\nconst SYMBOL_STORE_OBSERVABLE = Symbol(\"Observable\");\nconst SYMBOL_STORE_TARGET = Symbol(\"Target\");\nconst SYMBOL_STORE_VALUES = Symbol(\"Values\");\nconst SYMBOL_STORE_UNTRACKED = Symbol(\"Untracked\");\nconst SYMBOL_SUSPENSE$1 = Symbol(\"Suspense\");\nconst SYMBOL_UNCACHED = Symbol(\"Uncached\");\nconst SYMBOL_UNTRACKED = Symbol(\"Untracked\");\nconst SYMBOL_UNTRACKED_UNWRAPPED = Symbol(\"Unwrapped\");\nconst suspended = () => {\n  if (!SUSPENSE_ENABLED)\n    return void 0;\n  const suspense2 = SUSPENSE || OWNER.read(SYMBOL_SUSPENSE$1);\n  return suspense2 == null ? void 0 : suspense2.suspended;\n};\nconst lazyArrayEach = (arr, fn) => {\n  if (arr instanceof Array) {\n    arr.forEach(fn);\n  } else if (arr) {\n    fn(arr);\n  }\n};\nconst lazyArrayEachRight = (arr, fn) => {\n  if (arr instanceof Array) {\n    for (let i = arr.length - 1; i >= 0; i--) {\n      fn(arr[i]);\n    }\n  } else if (arr) {\n    fn(arr);\n  }\n};\nconst lazyArrayPush = (obj, key, value) => {\n  const arr = obj[key];\n  if (arr instanceof Array) {\n    arr.push(value);\n  } else if (arr) {\n    obj[key] = [arr, value];\n  } else {\n    obj[key] = value;\n  }\n};\nconst lazySetAdd = (obj, key, value) => {\n  const set = obj[key];\n  if (set instanceof Set) {\n    set.add(value);\n  } else if (set) {\n    if (value !== set) {\n      const s = /* @__PURE__ */ new Set();\n      s.add(set);\n      s.add(value);\n      obj[key] = s;\n    }\n  } else {\n    obj[key] = value;\n  }\n};\nconst lazySetDelete = (obj, key, value) => {\n  const set = obj[key];\n  if (set instanceof Set) {\n    set.delete(value);\n  } else if (set === value) {\n    obj[key] = void 0;\n  }\n};\nconst lazySetEach = (set, fn) => {\n  if (set instanceof Set) {\n    for (const value of set) {\n      fn(value);\n    }\n  } else if (set) {\n    fn(set);\n  }\n};\nconst lazySetHas = (set, value) => {\n  if (set instanceof Set) {\n    return set.has(value);\n  } else {\n    return set === value;\n  }\n};\nconst castArray$1 = (value) => {\n  return isArray$1(value) ? value : [value];\n};\nconst castError$1 = (error2) => {\n  if (error2 instanceof Error)\n    return error2;\n  if (typeof error2 === \"string\")\n    return new Error(error2);\n  return new Error(\"Unknown error\");\n};\nconst { is } = Object;\nconst { isArray: isArray$1 } = Array;\nconst isFunction$1 = (value) => {\n  return typeof value === \"function\";\n};\nconst isNumber = (value) => {\n  return typeof value === \"number\";\n};\nconst isObject$1 = (value) => {\n  return value !== null && typeof value === \"object\";\n};\nconst max = (a, b) => {\n  return a > b ? a : b;\n};\nconst noop = () => {\n  return;\n};\nconst nope = () => {\n  return false;\n};\nclass Observer {\n  constructor() {\n    __publicField(this, \"parent\");\n    __publicField(this, \"signal\");\n    __publicField(this, \"cleanups\");\n    __publicField(this, \"contexts\");\n    __publicField(this, \"errors\");\n    __publicField(this, \"observables\");\n    __publicField(this, \"observablesLeftover\");\n    __publicField(this, \"observers\");\n    __publicField(this, \"roots\");\n    __publicField(this, \"inactive\");\n  }\n  // Inactive observers should not be re-executed, if they can be\n  /* REGISTRATION API */\n  registerCleanup(cleanup2) {\n    lazyArrayPush(this, \"cleanups\", cleanup2);\n  }\n  registerError(error2) {\n    lazyArrayPush(this, \"errors\", error2);\n  }\n  registerObservable(observable2) {\n    lazyArrayPush(this, \"observables\", observable2);\n  }\n  registerObserver(observer) {\n    lazyArrayPush(this, \"observers\", observer);\n  }\n  registerRoot(root2) {\n    lazySetAdd(this, \"roots\", root2);\n  }\n  unregisterRoot(root2) {\n    lazySetDelete(this, \"roots\", root2);\n  }\n  /* API */\n  catch(error2, silent) {\n    const { errors, parent } = this;\n    if (errors) {\n      try {\n        lazyArrayEach(errors, (fn) => fn.call(fn, error2));\n      } catch (error22) {\n        if (parent) {\n          parent.catch(castError$1(error22), false);\n        } else {\n          throw error22;\n        }\n      }\n      return true;\n    } else {\n      if (parent == null ? void 0 : parent.catch(error2, true))\n        return true;\n      if (silent) {\n        return false;\n      } else {\n        throw error2;\n      }\n    }\n  }\n  dispose(deep, immediate) {\n    const { observers, observables, cleanups, errors, contexts } = this;\n    if (observers) {\n      this.observers = void 0;\n      lazyArrayEachRight(observers, (observer) => {\n        observer.dispose(true, true);\n      });\n    }\n    if (observables) {\n      this.observables = void 0;\n      if (immediate) {\n        lazyArrayEach(observables, (observable2) => {\n          if (!observable2.signal.disposed) {\n            observable2.unregisterObserver(this);\n          }\n        });\n      } else {\n        this.observablesLeftover = observables;\n      }\n    }\n    if (cleanups) {\n      this.cleanups = void 0;\n      this.inactive = true;\n      lazyArrayEachRight(cleanups, (cleanup2) => cleanup2.call(cleanup2));\n      this.inactive = false;\n    }\n    if (errors) {\n      this.errors = void 0;\n    }\n    if (contexts) {\n      this.contexts = void 0;\n    }\n  }\n  postdispose() {\n    const prev = this.observablesLeftover;\n    if (!prev)\n      return;\n    this.observablesLeftover = void 0;\n    const next = this.observables;\n    if (prev === next)\n      return;\n    const a = prev instanceof Array ? prev : [prev];\n    const b = next instanceof Array ? next : next ? [next] : [];\n    let bSet;\n    for (let ai = 0, al = a.length; ai < al; ai++) {\n      const av = a[ai];\n      if (av.signal.disposed)\n        continue;\n      if (av === b[ai])\n        continue;\n      bSet || (bSet = new Set(b));\n      if (bSet.has(av))\n        continue;\n      av.unregisterObserver(this);\n    }\n  }\n  read(symbol) {\n    const { contexts, parent } = this;\n    if (contexts && symbol in contexts)\n      return contexts[symbol];\n    return parent == null ? void 0 : parent.read(symbol);\n  }\n  write(symbol, value) {\n    this.contexts || (this.contexts = {});\n    this.contexts[symbol] = value;\n  }\n  wrap(fn, tracking = false) {\n    const ownerPrev = OWNER;\n    const trackingPrev = TRACKING;\n    setOwner(this);\n    setTracking(tracking);\n    let result;\n    try {\n      result = fn();\n    } catch (error2) {\n      this.catch(castError$1(error2), false);\n    } finally {\n      setOwner(ownerPrev);\n      setTracking(trackingPrev);\n    }\n    return result;\n  }\n}\nclass Root extends Observer {\n  /* CONSTRUCTOR */\n  constructor(pausable) {\n    super();\n    __publicField(this, \"parent\", OWNER);\n    __publicField(this, \"disposed\");\n    __publicField(this, \"pausable\");\n    if (pausable && isNumber(suspended())) {\n      this.pausable = true;\n      this.parent.registerRoot(this);\n    }\n  }\n  /* API */\n  dispose(deep, immediate) {\n    this.disposed = true;\n    if (this.pausable) {\n      this.parent.unregisterRoot(this);\n    }\n    super.dispose(deep, immediate);\n  }\n  wrap(fn) {\n    const dispose = this.dispose.bind(this, true, true);\n    const fnWithDispose = fn.bind(void 0, dispose);\n    const rootPrev = ROOT;\n    setRoot(this);\n    try {\n      return super.wrap(fnWithDispose);\n    } finally {\n      setRoot(rootPrev);\n    }\n  }\n}\nclass SuperRoot extends Observer {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"disposed\", false);\n  }\n}\nlet SUPER_OWNER = new SuperRoot();\nlet BATCH;\nlet OWNER = SUPER_OWNER;\nlet ROOT = SUPER_OWNER;\nlet ROOT_DISPOSED = Object.assign(new Root(), { disposed: true });\nlet SUSPENSE;\nlet SUSPENSE_ENABLED = false;\nlet TRACKING = false;\nconst setBatch = (value) => BATCH = value;\nconst setOwner = (value) => OWNER = value;\nconst setRoot = (value) => ROOT = value;\nconst setSuspense = (value) => SUSPENSE = value;\nconst setSuspenseEnabled = (value) => SUSPENSE_ENABLED = value;\nconst setTracking = (value) => TRACKING = value;\nconst start = () => {\n  setBatch(/* @__PURE__ */ new Map());\n};\nconst stop = () => {\n  const batch2 = BATCH;\n  if (!batch2)\n    return;\n  setBatch();\n  if (batch2.size > 1) {\n    batch2.forEach(stale);\n    batch2.forEach(write);\n    batch2.forEach(unstale);\n  } else {\n    batch2.forEach(write);\n  }\n};\nconst wrap = (fn, onBefore, onAfter) => {\n  onBefore();\n  try {\n    const result = fn();\n    if (result instanceof Promise) {\n      result.finally(onAfter);\n    } else {\n      onAfter();\n    }\n    return result;\n  } catch (error2) {\n    onAfter();\n    throw error2;\n  }\n};\nconst stale = (value, observable2) => {\n  observable2.emit(1, false);\n};\nconst unstale = (value, observable2) => {\n  observable2.emit(-1, false);\n};\nconst write = (value, observable2) => {\n  observable2.write(value);\n};\nconst batch = (fn) => {\n  if (BATCH) {\n    return fn();\n  } else {\n    return wrap(fn, start, stop);\n  }\n};\nfunction frozenFunction() {\n  if (arguments.length)\n    throw new Error(\"A readonly Observable can not be updated\");\n  return this;\n}\nfunction readableFunction(symbol) {\n  if (arguments.length) {\n    if (symbol === SYMBOL_OBSERVABLE)\n      return this;\n    throw new Error(\"A readonly Observable can not be updated\");\n  }\n  return this.read();\n}\nfunction writableFunction(fn) {\n  if (arguments.length) {\n    if (fn === SYMBOL_OBSERVABLE)\n      return this;\n    if (isFunction$1(fn))\n      return this.update(fn);\n    return this.write(fn);\n  }\n  return this.read();\n}\nconst frozen = (value) => {\n  const fn = frozenFunction.bind(value);\n  fn[SYMBOL_OBSERVABLE] = true;\n  fn[SYMBOL_OBSERVABLE_FROZEN] = true;\n  return fn;\n};\nconst readable = (value) => {\n  if (value.signal === ROOT_DISPOSED)\n    return frozen(value.value);\n  const fn = readableFunction.bind(value);\n  fn[SYMBOL_OBSERVABLE] = true;\n  fn[SYMBOL_OBSERVABLE_READABLE] = true;\n  return fn;\n};\nconst writable = (value) => {\n  const fn = writableFunction.bind(value);\n  fn[SYMBOL_OBSERVABLE] = true;\n  fn[SYMBOL_OBSERVABLE_WRITABLE] = true;\n  return fn;\n};\nconst getExecution = (status) => {\n  return status & 3;\n};\nconst setExecution = (status, execution) => {\n  return status >>> 2 << 2 | execution;\n};\nconst getFresh = (status) => {\n  return !!(status & 4);\n};\nconst setFresh = (status, fresh) => {\n  return fresh ? status | 4 : status;\n};\nconst getCount = (status) => {\n  return status >>> 3;\n};\nconst changeCount = (status, change) => {\n  return status + (change << 3);\n};\nclass Computation extends Observer {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"parent\", OWNER);\n    __publicField(this, \"signal\", ROOT);\n    __publicField(this, \"status\", 0);\n  }\n  /* API */\n  emit(change, fresh) {\n    if (change < 0 && !getCount(this.status))\n      return;\n    this.status = changeCount(this.status, change);\n    this.status = setFresh(this.status, fresh);\n    if (getCount(this.status))\n      return;\n    fresh = getFresh(this.status);\n    this.status = getExecution(this.status);\n    if (this.inactive)\n      return;\n    this.update(fresh);\n  }\n  update(fresh) {\n  }\n  wrap(fn, tracking = true) {\n    return super.wrap(fn, tracking);\n  }\n}\nclass Observable {\n  /* CONSTRUCTOR */\n  constructor(value, options, parent) {\n    __publicField(this, \"parent\");\n    __publicField(this, \"signal\", ROOT);\n    __publicField(this, \"value\");\n    __publicField(this, \"equals\");\n    __publicField(this, \"listeners\");\n    __publicField(this, \"observers\");\n    this.value = value;\n    if (parent) {\n      this.parent = parent;\n    }\n    if ((options == null ? void 0 : options.equals) !== void 0) {\n      this.equals = options.equals || nope;\n    }\n  }\n  /* REGISTRATION API */\n  registerListener(listener) {\n    if (lazySetHas(this.listeners, listener))\n      return;\n    lazySetAdd(this, \"listeners\", listener);\n  }\n  registerObserver(observer) {\n    lazySetAdd(this, \"observers\", observer);\n  }\n  registerSelf() {\n    if (this.signal.disposed)\n      return;\n    if (TRACKING) {\n      const owner2 = OWNER;\n      if (owner2.observables !== this) {\n        this.registerObserver(owner2);\n        owner2.registerObservable(this);\n      }\n    }\n    if (this.parent && getCount(this.parent.status)) {\n      this.parent.status = getExecution(this.parent.status);\n      this.parent.update(true);\n    }\n  }\n  unregisterListener(listener) {\n    lazySetDelete(this, \"listeners\", listener);\n  }\n  unregisterObserver(observer) {\n    lazySetDelete(this, \"observers\", observer);\n  }\n  /* API */\n  read() {\n    this.registerSelf();\n    return this.value;\n  }\n  write(value) {\n    if (this.signal === ROOT_DISPOSED)\n      throw new Error(\"A disposed Observable can not be updated\");\n    if (BATCH) {\n      BATCH.set(this, value);\n      return value;\n    } else {\n      const equals = this.equals || is;\n      const fresh = !equals(value, this.value);\n      if (!this.parent) {\n        if (!fresh)\n          return value;\n        if (!this.signal.disposed) {\n          this.emit(1, fresh);\n        }\n      }\n      if (fresh) {\n        const valuePrev = this.value;\n        this.value = value;\n        this.listened(valuePrev);\n      }\n      if (!this.signal.disposed) {\n        this.emit(-1, fresh);\n      }\n      return value;\n    }\n  }\n  update(fn) {\n    const valueNext = fn(this.value);\n    return this.write(valueNext);\n  }\n  emit(change, fresh) {\n    if (this.signal.disposed)\n      return;\n    const computations = this.observers;\n    if (computations) {\n      if (computations instanceof Set) {\n        for (const computation of computations) {\n          computation.emit(change, fresh);\n        }\n      } else {\n        computations.emit(change, fresh);\n      }\n    }\n  }\n  listened(valuePrev) {\n    if (this.signal.disposed)\n      return;\n    const { listeners } = this;\n    if (listeners) {\n      if (listeners instanceof Set) {\n        for (const listener of listeners) {\n          listener.call(listener, this.value, valuePrev);\n        }\n      } else {\n        listeners.call(listeners, this.value, valuePrev);\n      }\n    }\n  }\n  dispose() {\n    this.signal = ROOT_DISPOSED;\n  }\n}\nclass Memo extends Computation {\n  /* CONSTRUCTOR */\n  constructor(fn, options) {\n    super();\n    __publicField(this, \"fn\");\n    __publicField(this, \"observable\");\n    this.fn = fn;\n    this.observable = new Observable(void 0, options, this);\n    this.parent.registerObserver(this);\n    this.update(true, true);\n  }\n  /* API */\n  dispose(deep, immediate) {\n    if (deep && !this.signal.disposed) {\n      this.observable.dispose();\n    }\n    super.dispose(deep, immediate);\n  }\n  emit(change, fresh) {\n    if (change > 0 && !getCount(this.status)) {\n      this.observable.emit(change, false);\n    }\n    super.emit(change, fresh);\n  }\n  update(fresh, first) {\n    if (fresh && !this.observable.signal.disposed) {\n      const status = getExecution(this.status);\n      if (status) {\n        this.status = setExecution(this.status, fresh ? 3 : max(status, 2));\n        if (status > 1) {\n          this.observable.emit(-1, false);\n        }\n      } else {\n        this.status = setExecution(this.status, 1);\n        this.dispose();\n        try {\n          const value = this.wrap(this.fn);\n          this.postdispose();\n          if (this.observable.signal.disposed) {\n            this.observable.emit(-1, false);\n          } else if (first) {\n            this.observable.value = value;\n          } else {\n            this.observable.write(value);\n          }\n          if (!this.observers && !this.observables && !this.cleanups) {\n            this.dispose(true, true);\n          }\n        } catch (error2) {\n          this.postdispose();\n          this.catch(castError$1(error2), false);\n          this.observable.emit(-1, false);\n        } finally {\n          const status2 = getExecution(this.status);\n          this.status = setExecution(status2, 0);\n          if (status2 > 1) {\n            this.update(status2 === 3);\n          } else if (!this.observables) {\n            this.fn = noop;\n            this.observable.dispose();\n          }\n        }\n      }\n    } else {\n      this.observable.emit(-1, false);\n    }\n  }\n}\nconst memo = (fn, options) => {\n  const memo2 = new Memo(fn, options);\n  const observable2 = readable(memo2.observable);\n  return observable2;\n};\nconst isObservableFrozen = (value) => {\n  return isFunction$1(value) && SYMBOL_OBSERVABLE_FROZEN in value;\n};\nconst unwrap = (value) => {\n  if (isObservableFrozen(value)) {\n    return value();\n  } else {\n    return value;\n  }\n};\nconst boolean = (value) => {\n  if (isFunction$1(value)) {\n    return unwrap(memo(() => !!value()));\n  } else {\n    return !!value;\n  }\n};\nconst cleanup = (fn) => {\n  OWNER.registerCleanup(fn);\n};\nfunction context(symbol, value) {\n  if (arguments.length < 2) {\n    return OWNER.read(symbol);\n  } else {\n    return OWNER.write(symbol, value);\n  }\n}\nconst disposed = () => {\n  const observable2 = new Observable(false);\n  cleanup(() => {\n    observable2.write(true);\n  });\n  return readable(observable2);\n};\nclass Reaction extends Computation {\n  /* CONSTRUCTOR */\n  constructor(fn, pausable) {\n    super();\n    __publicField(this, \"fn\");\n    this.fn = fn;\n    this.parent.registerObserver(this);\n    if (pausable && suspended()) {\n      this.emit(1, true);\n    } else {\n      this.update(true);\n    }\n  }\n  /* API */\n  update(fresh) {\n    if (fresh && !this.signal.disposed) {\n      const status = getExecution(this.status);\n      if (status) {\n        this.status = setExecution(this.status, fresh ? 3 : max(status, 2));\n      } else {\n        this.status = setExecution(this.status, 1);\n        this.dispose();\n        try {\n          const cleanup2 = this.wrap(this.fn);\n          this.postdispose();\n          if (isFunction$1(cleanup2)) {\n            this.registerCleanup(cleanup2);\n          } else {\n            if (!this.observers && !this.observables && !this.cleanups) {\n              this.dispose(true, true);\n            }\n          }\n        } catch (error2) {\n          this.postdispose();\n          this.catch(castError$1(error2), false);\n        } finally {\n          const status2 = getExecution(this.status);\n          this.status = setExecution(this.status, 0);\n          if (status2 > 1) {\n            this.update(status2 === 3);\n          } else if (!this.observables) {\n            this.fn = noop;\n          }\n        }\n      }\n    }\n  }\n}\nclass Effect extends Reaction {\n  /* CONSTRUCTOR */\n  constructor(fn) {\n    super(fn, true);\n  }\n}\nconst effect = (fn) => {\n  const effect2 = new Effect(fn);\n  const dispose = effect2.dispose.bind(effect2, true, true);\n  return dispose;\n};\nconst error = (fn) => {\n  OWNER.registerError(fn);\n};\nconst isObservable = (value) => {\n  return isFunction$1(value) && (SYMBOL_OBSERVABLE_FROZEN in value || SYMBOL_OBSERVABLE_READABLE in value || SYMBOL_OBSERVABLE_WRITABLE in value);\n};\nfunction get(value, getFunction = true) {\n  const is2 = getFunction ? isFunction$1 : isObservable;\n  if (is2(value)) {\n    return value();\n  } else {\n    return value;\n  }\n}\nconst isStore = (value) => {\n  return isObject$1(value) && SYMBOL_STORE in value;\n};\nconst resolve = (value) => {\n  if (isFunction$1(value)) {\n    if (SYMBOL_UNTRACKED_UNWRAPPED in value) {\n      return resolve(value());\n    } else if (SYMBOL_UNTRACKED in value) {\n      return frozen(resolve(value()));\n    } else if (SYMBOL_OBSERVABLE in value) {\n      return value;\n    } else {\n      return memo(() => resolve(value()));\n    }\n  }\n  if (value instanceof Array) {\n    const resolved = new Array(value.length);\n    for (let i = 0, l = resolved.length; i < l; i++) {\n      resolved[i] = resolve(value[i]);\n    }\n    return resolved;\n  } else {\n    return value;\n  }\n};\nfunction untrack(fn) {\n  if (isFunction$1(fn)) {\n    const trackingPrev = TRACKING;\n    try {\n      setTracking(false);\n      return fn();\n    } finally {\n      setTracking(trackingPrev);\n    }\n  } else {\n    return fn;\n  }\n}\nconst forAbstract = (Cache5, values, fn, fallback = []) => {\n  const cache = new Cache5(fn);\n  const { dispose, map } = cache;\n  cleanup(dispose);\n  const value = memo(() => {\n    return get(values);\n  }, {\n    equals: (a, b) => {\n      return !!a && !!b && !a.length && !b.length && !isStore(a) && !isStore(b);\n    }\n  });\n  return memo(() => {\n    const array = value();\n    if (isStore(array))\n      array[SYMBOL_STORE_VALUES];\n    return untrack(() => {\n      const results = map(array);\n      return (results == null ? void 0 : results.length) ? results : resolve(fallback);\n    });\n  });\n};\nlet Cache$3 = class Cache {\n  /* CONSTRUCTOR */\n  constructor(fn) {\n  }\n  /* API */\n  dispose() {\n  }\n  map(values) {\n  }\n};\nconst DUMMY_INDEX$1 = frozen(-1);\nlet MappedRoot$1 = class MappedRoot extends Root {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"bool\");\n    __publicField(this, \"index\");\n    __publicField(this, \"result\");\n  }\n};\nlet Cache$2 = class Cache2 extends Cache$3 {\n  /* CONSTRUCTOR */\n  constructor(fn) {\n    super(fn);\n    __publicField(this, \"fn\");\n    __publicField(this, \"fnWithIndex\");\n    __publicField(this, \"cache\", /* @__PURE__ */ new Map());\n    __publicField(this, \"bool\", false);\n    __publicField(this, \"prevCount\", 0);\n    __publicField(this, \"reuseCount\", 0);\n    __publicField(this, \"nextCount\", 0);\n    __publicField(this, \"parent\", OWNER);\n    __publicField(this, \"cleanup\", () => {\n      if (!this.prevCount)\n        return;\n      if (this.prevCount === this.reuseCount)\n        return;\n      const { cache, bool } = this;\n      if (!cache.size)\n        return;\n      if (this.nextCount) {\n        cache.forEach((mapped, value) => {\n          if (mapped.bool === bool)\n            return;\n          mapped.dispose(true, true);\n          cache.delete(value);\n        });\n      } else {\n        this.cache.forEach((mapped) => {\n          mapped.dispose(true, true);\n        });\n        this.cache = /* @__PURE__ */ new Map();\n      }\n    });\n    __publicField(this, \"dispose\", () => {\n      this.parent.unregisterRoot(this.roots);\n      this.prevCount = this.cache.size;\n      this.reuseCount = 0;\n      this.nextCount = 0;\n      this.cleanup();\n    });\n    __publicField(this, \"before\", (values) => {\n      this.bool = !this.bool;\n      this.reuseCount = 0;\n      this.nextCount = 0;\n    });\n    __publicField(this, \"after\", (values) => {\n      this.nextCount = values.length;\n      this.cleanup();\n      this.prevCount = this.nextCount;\n      this.reuseCount = 0;\n    });\n    __publicField(this, \"map\", (values) => {\n      var _a;\n      this.before(values);\n      const { cache, bool, fn: fn2, fnWithIndex } = this;\n      const results = new Array(values.length);\n      let uncached = true;\n      let reuseCount = 0;\n      for (let i = 0, l = values.length; i < l; i++) {\n        const value = values[i];\n        const cached = cache.get(value);\n        if (cached && cached.bool !== bool) {\n          uncached = false;\n          reuseCount += 1;\n          cached.bool = bool;\n          (_a = cached.index) == null ? void 0 : _a.write(i);\n          results[i] = cached.result;\n        } else {\n          const mapped = new MappedRoot$1();\n          if (cached) {\n            cleanup(() => mapped.dispose());\n          }\n          mapped.wrap(() => {\n            let index = DUMMY_INDEX$1;\n            if (fnWithIndex) {\n              mapped.index = new Observable(i);\n              index = readable(mapped.index);\n            }\n            const result = results[i] = resolve(fn2(value, index));\n            mapped.bool = bool;\n            mapped.result = result;\n            if (!cached) {\n              cache.set(value, mapped);\n            }\n          });\n        }\n      }\n      this.reuseCount = reuseCount;\n      this.after(values);\n      if (uncached) {\n        results[SYMBOL_UNCACHED] = true;\n      }\n      return results;\n    });\n    __publicField(this, \"roots\", () => {\n      return Array.from(this.cache.values());\n    });\n    this.fn = fn;\n    this.fnWithIndex = fn.length > 1;\n    this.parent.registerRoot(this.roots);\n  }\n};\nconst _for = (values, fn, fallback = []) => {\n  return forAbstract(Cache$2, values, fn, fallback);\n};\nclass IndexedRoot extends Root {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"source\");\n    __publicField(this, \"target\");\n    __publicField(this, \"result\");\n  }\n}\nlet Cache$1 = class Cache3 extends Cache$3 {\n  /* CONSTRUCTOR */\n  constructor(fn) {\n    super(fn);\n    __publicField(this, \"fn\");\n    __publicField(this, \"cache\");\n    __publicField(this, \"parent\", OWNER);\n    __publicField(this, \"cleanup\", (startIndex) => {\n      const { cache } = this;\n      for (let i = startIndex, l = cache.length; i < l; i++) {\n        cache[i].dispose(true, true);\n      }\n      cache.length = startIndex;\n    });\n    __publicField(this, \"dispose\", () => {\n      this.parent.unregisterRoot(this.roots);\n      this.cleanup(0);\n    });\n    __publicField(this, \"map\", (values) => {\n      const { cache, fn: fn2 } = this;\n      const results = new Array(values.length);\n      for (let i = 0, l = values.length; i < l; i++) {\n        const value = values[i];\n        const cached = cache[i];\n        if (cached) {\n          cached.source.write(value);\n          results[i] = cached.result;\n        } else {\n          const indexed = new IndexedRoot();\n          indexed.wrap(() => {\n            const source = new Observable(value);\n            const target2 = memo(() => get(source.read()));\n            indexed.source = source;\n            indexed.target = target2;\n            indexed.result = resolve(fn2(target2, i));\n            cache[i] = indexed;\n            results[i] = indexed.result;\n          });\n        }\n      }\n      this.cleanup(values.length);\n      return results;\n    });\n    __publicField(this, \"roots\", () => {\n      return Array.from(this.cache.values());\n    });\n    this.fn = fn;\n    this.cache = [];\n    this.parent.registerRoot(this.roots);\n  }\n};\nconst forIndex = (values, fn, fallback = []) => {\n  return forAbstract(Cache$1, values, fn, fallback);\n};\nconst DUMMY_INDEX = frozen(-1);\nclass MappedRoot2 extends Root {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"index\");\n    __publicField(this, \"value\");\n    __publicField(this, \"result\");\n  }\n}\nclass Cache4 extends Cache$3 {\n  /* CONSTRUCTOR */\n  constructor(fn) {\n    super(fn);\n    __publicField(this, \"fn\");\n    __publicField(this, \"fnWithIndex\");\n    __publicField(this, \"cache\", /* @__PURE__ */ new Map());\n    __publicField(this, \"parent\", OWNER);\n    __publicField(this, \"cleanup\", () => {\n      this.cache.forEach((mapped) => {\n        mapped.dispose(true, true);\n      });\n    });\n    __publicField(this, \"dispose\", () => {\n      this.parent.unregisterRoot(this.roots);\n      this.cleanup();\n    });\n    __publicField(this, \"map\", (values) => {\n      var _a, _b, _c;\n      const { cache, fn: fn2, fnWithIndex } = this;\n      const cacheNext = /* @__PURE__ */ new Map();\n      const results = new Array(values.length);\n      let leftovers = [];\n      if (cache.size) {\n        for (let i = 0, l = values.length; i < l; i++) {\n          const value = values[i];\n          const cached = cache.get(value);\n          if (cached) {\n            cache.delete(value);\n            cacheNext.set(value, cached);\n            (_a = cached.index) == null ? void 0 : _a.write(i);\n            results[i] = cached.result;\n          } else {\n            leftovers.push(i);\n          }\n        }\n      } else {\n        leftovers = new Array(results.length);\n      }\n      outer:\n        for (let i = 0, l = leftovers.length; i < l; i++) {\n          const index = leftovers[i] || i;\n          const value = values[index];\n          const isDuplicate = cacheNext.has(value);\n          if (!isDuplicate) {\n            for (const [key, mapped2] of cache.entries()) {\n              cache.delete(key);\n              cacheNext.set(value, mapped2);\n              if (fnWithIndex) {\n                batch(() => {\n                  var _a2, _b2;\n                  (_a2 = mapped2.index) == null ? void 0 : _a2.write(index);\n                  (_b2 = mapped2.value) == null ? void 0 : _b2.write(value);\n                });\n              } else {\n                (_b = mapped2.index) == null ? void 0 : _b.write(index);\n                (_c = mapped2.value) == null ? void 0 : _c.write(value);\n              }\n              results[index] = mapped2.result;\n              continue outer;\n            }\n          }\n          const mapped = new MappedRoot2();\n          if (isDuplicate) {\n            cleanup(() => mapped.dispose());\n          }\n          mapped.wrap(() => {\n            let $index = DUMMY_INDEX;\n            if (fnWithIndex) {\n              mapped.index = new Observable(index);\n              $index = readable(mapped.index);\n            }\n            const observable2 = mapped.value = new Observable(value);\n            const $value = memo(() => get(observable2.read()));\n            const result = results[index] = resolve(fn2($value, $index));\n            mapped.value = observable2;\n            mapped.result = result;\n            if (!isDuplicate) {\n              cacheNext.set(value, mapped);\n            }\n          });\n        }\n      this.cleanup();\n      this.cache = cacheNext;\n      return results;\n    });\n    __publicField(this, \"roots\", () => {\n      return Array.from(this.cache.values());\n    });\n    this.fn = fn;\n    this.fnWithIndex = fn.length > 1;\n    this.parent.registerRoot(this.roots);\n  }\n}\nconst forValue = (values, fn, fallback = []) => {\n  return forAbstract(Cache4, values, fn, fallback);\n};\nfunction _switch(when, values, fallback) {\n  const value = resolve(memo(() => {\n    const condition = get(when);\n    for (let i = 0, l = values.length; i < l; i++) {\n      const value2 = values[i];\n      if (value2.length === 1)\n        return value2[0];\n      if (is(value2[0], condition))\n        return value2[1];\n    }\n    return fallback;\n  }));\n  return memo(() => {\n    return resolve(get(value));\n  });\n}\nconst ternary = (when, valueTrue, valueFalse) => {\n  const condition = boolean(when);\n  return _switch(condition, [[true, valueTrue], [valueFalse]]);\n};\nconst isBatching = () => {\n  return !!BATCH;\n};\nconst target = (observable2) => {\n  if (isFunction$1(observable2)) {\n    return observable2(SYMBOL_OBSERVABLE);\n  } else {\n    return observable2;\n  }\n};\nconst off = (observable2, listener) => {\n  if (!isObservableFrozen(observable2)) {\n    target(observable2).unregisterListener(listener);\n  }\n};\nconst on = (observable2, listener) => {\n  if (!isObservableFrozen(observable2)) {\n    target(observable2).registerListener(listener);\n  }\n  return () => {\n    off(observable2, listener);\n  };\n};\nclass Suspense extends Observer {\n  // 0: UNSUSPENDED, 1: THIS_SUSPENDED, 2+: THIS_AND_PARENT_SUSPENDED\n  /* CONSTRUCTOR */\n  constructor() {\n    super();\n    __publicField(this, \"parent\", OWNER);\n    __publicField(this, \"suspended\", suspended() || 0);\n    setSuspenseEnabled(true);\n    OWNER.registerObserver(this);\n    this.write(SYMBOL_SUSPENSE$1, this);\n  }\n  /* API */\n  toggle(force) {\n    if (!this.suspended && !force)\n      return;\n    const suspendedPrev = this.suspended;\n    this.suspended += force ? 1 : -1;\n    if (suspendedPrev >= 2)\n      return;\n    const notifyRoot = (root2) => {\n      if (isFunction$1(root2)) {\n        root2().forEach(notifyObserver);\n      } else {\n        notifyObserver(root2);\n      }\n    };\n    const notifyObserver = (observer) => {\n      if (observer instanceof Suspense)\n        return;\n      if (observer instanceof Effect) {\n        observer.emit(force ? 1 : -1, false);\n      }\n      lazyArrayEach(observer.observers, notifyObserver);\n      lazySetEach(observer.roots, notifyRoot);\n    };\n    const notifySuspense = (observer) => {\n      if (!(observer instanceof Suspense))\n        return;\n      observer.toggle(force);\n    };\n    lazyArrayEach(this.observers, notifyObserver);\n    lazyArrayEach(this.observers, notifySuspense);\n    lazySetEach(this.roots, notifyRoot);\n  }\n  wrap(fn) {\n    const suspensePrev = SUSPENSE;\n    setSuspense(this);\n    try {\n      return super.wrap(fn);\n    } finally {\n      setSuspense(suspensePrev);\n    }\n  }\n}\nconst owner = () => {\n  const isSuperRoot = OWNER instanceof SuperRoot;\n  const isRoot = OWNER instanceof Root;\n  const isSuspense = OWNER instanceof Suspense;\n  const isComputation = OWNER instanceof Computation;\n  return { isSuperRoot, isRoot, isSuspense, isComputation };\n};\nconst reaction = (fn) => {\n  const reaction2 = new Reaction(fn);\n  const dispose = reaction2.dispose.bind(reaction2, true, true);\n  return dispose;\n};\nconst isObservableWritable = (value) => {\n  return isFunction$1(value) && SYMBOL_OBSERVABLE_WRITABLE in value;\n};\nconst readonly = (observable2) => {\n  if (isObservableWritable(observable2)) {\n    return readable(target(observable2));\n  } else {\n    return observable2;\n  }\n};\nconst root = (fn) => {\n  return new Root(true).wrap(fn);\n};\nconst OBSERVABLE_FALSE = frozen(false);\nconst OBSERVABLE_TRUE = frozen(true);\nclass DisposableMap extends Map {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"disposed\", false);\n  }\n}\nclass SelectedObservable extends Observable {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"count\", 1);\n    __publicField(this, \"selecteds\");\n    __publicField(this, \"source\");\n  }\n  /* API */\n  call() {\n    if (this.selecteds.disposed)\n      return;\n    this.count -= 1;\n    if (this.count)\n      return;\n    this.dispose();\n    this.selecteds.delete(this.source);\n  }\n}\nconst selector = (source) => {\n  source = memo(source);\n  if (isObservableFrozen(source)) {\n    const sourceValue = source();\n    return (value) => {\n      return value === sourceValue ? OBSERVABLE_TRUE : OBSERVABLE_FALSE;\n    };\n  }\n  const signal = { disposed: false };\n  let selecteds = new DisposableMap();\n  let selectedValue;\n  reaction(() => {\n    var _a, _b;\n    const valuePrev = selectedValue;\n    const valueNext = source();\n    if (is(valuePrev, valueNext))\n      return;\n    selectedValue = valueNext;\n    (_a = selecteds.get(valuePrev)) == null ? void 0 : _a.write(false);\n    (_b = selecteds.get(valueNext)) == null ? void 0 : _b.write(true);\n  });\n  const cleanupAll = () => {\n    signal.disposed = true;\n    selecteds.disposed = true;\n  };\n  cleanup(cleanupAll);\n  return (value) => {\n    if (signal.disposed)\n      throw new Error(\"A disposed Selector can not be used anymore\");\n    let selected = selecteds.get(value);\n    if (selected) {\n      selected.count += 1;\n    } else {\n      selected = new SelectedObservable(value === selectedValue);\n      selected.selecteds = selecteds;\n      selected.source = value;\n      selected.signal = signal;\n      selecteds.set(value, selected);\n    }\n    cleanup(selected);\n    return readable(selected);\n  };\n};\nclass StoreMap extends Map {\n  insert(key, value) {\n    super.set(key, value);\n    return value;\n  }\n}\nclass StoreCleanable {\n  constructor() {\n    __publicField(this, \"count\", 0);\n  }\n  listen() {\n    this.count += 1;\n    cleanup(this);\n  }\n  call() {\n    this.count -= 1;\n    if (this.count)\n      return;\n    this.dispose();\n  }\n  dispose() {\n  }\n}\nclass StoreKeys extends StoreCleanable {\n  constructor(parent, observable2) {\n    super();\n    this.parent = parent;\n    this.observable = observable2;\n  }\n  dispose() {\n    this.parent.keys = void 0;\n  }\n}\nclass StoreValues extends StoreCleanable {\n  constructor(parent, observable2) {\n    super();\n    this.parent = parent;\n    this.observable = observable2;\n  }\n  dispose() {\n    this.parent.values = void 0;\n  }\n}\nclass StoreHas extends StoreCleanable {\n  constructor(parent, key, observable2) {\n    super();\n    this.parent = parent;\n    this.key = key;\n    this.observable = observable2;\n  }\n  dispose() {\n    var _a;\n    (_a = this.parent.has) == null ? void 0 : _a.delete(this.key);\n  }\n}\nclass StoreProperty extends StoreCleanable {\n  constructor(parent, key, observable2, node) {\n    super();\n    this.parent = parent;\n    this.key = key;\n    this.observable = observable2;\n    this.node = node;\n  }\n  dispose() {\n    var _a;\n    (_a = this.parent.properties) == null ? void 0 : _a.delete(this.key);\n  }\n}\nconst StoreListenersRegular = {\n  /* VARIABLES */\n  active: 0,\n  listeners: /* @__PURE__ */ new Set(),\n  nodes: /* @__PURE__ */ new Set(),\n  /* API */\n  prepare: () => {\n    const { listeners, nodes } = StoreListenersRegular;\n    const traversed = /* @__PURE__ */ new Set();\n    const traverse = (node) => {\n      if (traversed.has(node))\n        return;\n      traversed.add(node);\n      lazySetEach(node.parents, traverse);\n      lazySetEach(node.listenersRegular, (listener) => {\n        listeners.add(listener);\n      });\n    };\n    nodes.forEach(traverse);\n    return () => {\n      listeners.forEach((listener) => {\n        listener();\n      });\n    };\n  },\n  register: (node) => {\n    StoreListenersRegular.nodes.add(node);\n    StoreScheduler.schedule();\n  },\n  reset: () => {\n    StoreListenersRegular.listeners = /* @__PURE__ */ new Set();\n    StoreListenersRegular.nodes = /* @__PURE__ */ new Set();\n  }\n};\nconst StoreListenersRoots = {\n  /* VARIABLES */\n  active: 0,\n  nodes: /* @__PURE__ */ new Map(),\n  /* API */\n  prepare: () => {\n    const { nodes } = StoreListenersRoots;\n    return () => {\n      nodes.forEach((rootsSet, store2) => {\n        const roots = Array.from(rootsSet);\n        lazySetEach(store2.listenersRoots, (listener) => {\n          listener(roots);\n        });\n      });\n    };\n  },\n  register: (store2, root2) => {\n    const roots = StoreListenersRoots.nodes.get(store2) || /* @__PURE__ */ new Set();\n    roots.add(root2);\n    StoreListenersRoots.nodes.set(store2, roots);\n    StoreScheduler.schedule();\n  },\n  registerWith: (current, parent, key) => {\n    if (!parent.parents) {\n      const root2 = (current == null ? void 0 : current.store) || untrack(() => parent.store[key]);\n      StoreListenersRoots.register(parent, root2);\n    } else {\n      const traversed = /* @__PURE__ */ new Set();\n      const traverse = (node) => {\n        if (traversed.has(node))\n          return;\n        traversed.add(node);\n        lazySetEach(node.parents, (parent2) => {\n          if (!parent2.parents) {\n            StoreListenersRoots.register(parent2, node.store);\n          }\n          traverse(parent2);\n        });\n      };\n      traverse(current || parent);\n    }\n  },\n  reset: () => {\n    StoreListenersRoots.nodes = /* @__PURE__ */ new Map();\n  }\n};\nconst StoreScheduler = {\n  /* VARIABLES */\n  active: false,\n  /* API */\n  flush: () => {\n    const flushRegular = StoreListenersRegular.prepare();\n    const flushRoots = StoreListenersRoots.prepare();\n    StoreScheduler.reset();\n    flushRegular();\n    flushRoots();\n  },\n  flushIfNotBatching: () => {\n    if (isBatching()) {\n      setTimeout(StoreScheduler.flushIfNotBatching, 0);\n    } else {\n      StoreScheduler.flush();\n    }\n  },\n  reset: () => {\n    StoreScheduler.active = false;\n    StoreListenersRegular.reset();\n    StoreListenersRoots.reset();\n  },\n  schedule: () => {\n    if (StoreScheduler.active)\n      return;\n    StoreScheduler.active = true;\n    queueMicrotask(StoreScheduler.flushIfNotBatching);\n  }\n};\nconst NODES = /* @__PURE__ */ new WeakMap();\nconst SPECIAL_SYMBOLS = /* @__PURE__ */ new Set([SYMBOL_STORE, SYMBOL_STORE_KEYS, SYMBOL_STORE_OBSERVABLE, SYMBOL_STORE_TARGET, SYMBOL_STORE_VALUES]);\nconst UNREACTIVE_KEYS = /* @__PURE__ */ new Set([\"__proto__\", \"__defineGetter__\", \"__defineSetter__\", \"__lookupGetter__\", \"__lookupSetter__\", \"prototype\", \"constructor\", \"hasOwnProperty\", \"isPrototypeOf\", \"propertyIsEnumerable\", \"toLocaleString\", \"toSource\", \"toString\", \"valueOf\"]);\nconst STORE_TRAPS = {\n  /* API */\n  get: (target2, key) => {\n    var _a, _b;\n    if (SPECIAL_SYMBOLS.has(key)) {\n      if (key === SYMBOL_STORE)\n        return true;\n      if (key === SYMBOL_STORE_TARGET)\n        return target2;\n      if (key === SYMBOL_STORE_KEYS) {\n        if (isListenable()) {\n          const node2 = getNodeExisting(target2);\n          node2.keys || (node2.keys = getNodeKeys(node2));\n          node2.keys.listen();\n          node2.keys.observable.read();\n        }\n        return;\n      }\n      if (key === SYMBOL_STORE_VALUES) {\n        if (isListenable()) {\n          const node2 = getNodeExisting(target2);\n          node2.values || (node2.values = getNodeValues(node2));\n          node2.values.listen();\n          node2.values.observable.read();\n        }\n        return;\n      }\n      if (key === SYMBOL_STORE_OBSERVABLE) {\n        return (key2) => {\n          var _a2;\n          key2 = typeof key2 === \"number\" ? String(key2) : key2;\n          const node2 = getNodeExisting(target2);\n          const getter2 = (_a2 = node2.getters) == null ? void 0 : _a2.get(key2);\n          if (getter2)\n            return getter2.bind(node2.store);\n          node2.properties || (node2.properties = new StoreMap());\n          const value2 = target2[key2];\n          const property2 = node2.properties.get(key2) || node2.properties.insert(key2, getNodeProperty(node2, key2, value2));\n          const options = node2.equals ? { equals: node2.equals } : void 0;\n          property2.observable || (property2.observable = getNodeObservable(node2, value2, options));\n          const observable2 = readable(property2.observable);\n          return observable2;\n        };\n      }\n    }\n    if (UNREACTIVE_KEYS.has(key))\n      return target2[key];\n    const node = getNodeExisting(target2);\n    const getter = (_a = node.getters) == null ? void 0 : _a.get(key);\n    const value = getter || target2[key];\n    node.properties || (node.properties = new StoreMap());\n    const listenable = isListenable();\n    const proxiable = isProxiable(value);\n    const property = listenable || proxiable ? node.properties.get(key) || node.properties.insert(key, getNodeProperty(node, key, value)) : void 0;\n    if (property == null ? void 0 : property.node) {\n      lazySetAdd(property.node, \"parents\", node);\n    }\n    if (property && listenable) {\n      const options = node.equals ? { equals: node.equals } : void 0;\n      property.listen();\n      property.observable || (property.observable = getNodeObservable(node, value, options));\n      property.observable.read();\n    }\n    if (getter) {\n      return getter.call(node.store);\n    } else {\n      if (typeof value === \"function\" && value === Array.prototype[key]) {\n        return function() {\n          return batch(() => value.apply(node.store, arguments));\n        };\n      }\n      return ((_b = property == null ? void 0 : property.node) == null ? void 0 : _b.store) || value;\n    }\n  },\n  set: (target2, key, value) => {\n    var _a;\n    value = getTarget(value);\n    const node = getNodeExisting(target2);\n    const setter = (_a = node.setters) == null ? void 0 : _a.get(key);\n    if (setter) {\n      batch(() => setter.call(node.store, value));\n    } else {\n      const valuePrev = target2[key];\n      const hadProperty = !!valuePrev || key in target2;\n      const equals = node.equals || is;\n      if (hadProperty && equals(value, valuePrev) && (key !== \"length\" || !Array.isArray(target2)))\n        return true;\n      target2[key] = value;\n      batch(() => {\n        var _a2, _b, _c, _d, _e, _f;\n        (_a2 = node.values) == null ? void 0 : _a2.observable.write(0);\n        if (!hadProperty) {\n          (_b = node.keys) == null ? void 0 : _b.observable.write(0);\n          (_d = (_c = node.has) == null ? void 0 : _c.get(key)) == null ? void 0 : _d.observable.write(true);\n        }\n        const property = (_e = node.properties) == null ? void 0 : _e.get(key);\n        if (property == null ? void 0 : property.node) {\n          lazySetDelete(property.node, \"parents\", node);\n        }\n        if (property) {\n          (_f = property.observable) == null ? void 0 : _f.write(value);\n          property.node = isProxiable(value) ? NODES.get(value) || getNode(value, node) : void 0;\n        }\n        if (property == null ? void 0 : property.node) {\n          lazySetAdd(property.node, \"parents\", node);\n        }\n        if (StoreListenersRoots.active) {\n          StoreListenersRoots.registerWith(property == null ? void 0 : property.node, node, key);\n        }\n        if (StoreListenersRegular.active) {\n          StoreListenersRegular.register(node);\n        }\n      });\n    }\n    return true;\n  },\n  deleteProperty: (target2, key) => {\n    const hasProperty = key in target2;\n    if (!hasProperty)\n      return true;\n    const deleted = Reflect.deleteProperty(target2, key);\n    if (!deleted)\n      return false;\n    const node = getNodeExisting(target2);\n    batch(() => {\n      var _a, _b, _c, _d, _e, _f;\n      (_a = node.keys) == null ? void 0 : _a.observable.write(0);\n      (_b = node.values) == null ? void 0 : _b.observable.write(0);\n      (_d = (_c = node.has) == null ? void 0 : _c.get(key)) == null ? void 0 : _d.observable.write(false);\n      const property = (_e = node.properties) == null ? void 0 : _e.get(key);\n      if (StoreListenersRoots.active) {\n        StoreListenersRoots.registerWith(property == null ? void 0 : property.node, node, key);\n      }\n      if (property == null ? void 0 : property.node) {\n        lazySetDelete(property.node, \"parents\", node);\n      }\n      if (property) {\n        (_f = property.observable) == null ? void 0 : _f.write(void 0);\n        property.node = void 0;\n      }\n      if (StoreListenersRegular.active) {\n        StoreListenersRegular.register(node);\n      }\n    });\n    return true;\n  },\n  defineProperty: (target2, key, descriptor) => {\n    const node = getNodeExisting(target2);\n    const equals = node.equals || is;\n    const hadProperty = key in target2;\n    const descriptorPrev = Reflect.getOwnPropertyDescriptor(target2, key);\n    if (descriptorPrev && isEqualDescriptor(descriptorPrev, descriptor, equals))\n      return true;\n    const defined = Reflect.defineProperty(target2, key, descriptor);\n    if (!defined)\n      return false;\n    batch(() => {\n      var _a, _b, _c, _d, _e, _f, _g, _h;\n      if (!descriptor.get) {\n        (_a = node.getters) == null ? void 0 : _a.delete(key);\n      } else if (descriptor.get) {\n        node.getters || (node.getters = new StoreMap());\n        node.getters.set(key, descriptor.get);\n      }\n      if (!descriptor.set) {\n        (_b = node.setters) == null ? void 0 : _b.delete(key);\n      } else if (descriptor.set) {\n        node.setters || (node.setters = new StoreMap());\n        node.setters.set(key, descriptor.set);\n      }\n      if (hadProperty !== !!descriptor.enumerable) {\n        (_c = node.keys) == null ? void 0 : _c.observable.write(0);\n        (_e = (_d = node.has) == null ? void 0 : _d.get(key)) == null ? void 0 : _e.observable.write(!!descriptor.enumerable);\n      }\n      const property = (_f = node.properties) == null ? void 0 : _f.get(key);\n      if (StoreListenersRoots.active) {\n        StoreListenersRoots.registerWith(property == null ? void 0 : property.node, node, key);\n      }\n      if (property == null ? void 0 : property.node) {\n        lazySetDelete(property.node, \"parents\", node);\n      }\n      if (property) {\n        if (\"get\" in descriptor) {\n          (_g = property.observable) == null ? void 0 : _g.write(descriptor.get);\n          property.node = void 0;\n        } else {\n          const value = descriptor[\"value\"];\n          (_h = property.observable) == null ? void 0 : _h.write(value);\n          property.node = isProxiable(value) ? NODES.get(value) || getNode(value, node) : void 0;\n        }\n      }\n      if (property == null ? void 0 : property.node) {\n        lazySetAdd(property.node, \"parents\", node);\n      }\n      if (StoreListenersRoots.active) {\n        StoreListenersRoots.registerWith(property == null ? void 0 : property.node, node, key);\n      }\n      if (StoreListenersRegular.active) {\n        StoreListenersRegular.register(node);\n      }\n    });\n    return true;\n  },\n  has: (target2, key) => {\n    if (key === SYMBOL_STORE)\n      return true;\n    if (key === SYMBOL_STORE_TARGET)\n      return true;\n    const value = key in target2;\n    if (isListenable()) {\n      const node = getNodeExisting(target2);\n      node.has || (node.has = new StoreMap());\n      const has = node.has.get(key) || node.has.insert(key, getNodeHas(node, key, value));\n      has.listen();\n      has.observable.read();\n    }\n    return value;\n  },\n  ownKeys: (target2) => {\n    const keys = Reflect.ownKeys(target2);\n    if (isListenable()) {\n      const node = getNodeExisting(target2);\n      node.keys || (node.keys = getNodeKeys(node));\n      node.keys.listen();\n      node.keys.observable.read();\n    }\n    return keys;\n  }\n};\nconst STORE_UNTRACK_TRAPS = {\n  /* API */\n  has: (target2, key) => {\n    if (key === SYMBOL_STORE_UNTRACKED)\n      return true;\n    return key in target2;\n  }\n};\nconst getNode = (value, parent, equals) => {\n  const store2 = new Proxy(value, STORE_TRAPS);\n  const signal = (parent == null ? void 0 : parent.signal) || ROOT;\n  const gettersAndSetters = getGettersAndSetters(value);\n  const node = { parents: parent, store: store2, signal };\n  if (gettersAndSetters) {\n    const { getters, setters } = gettersAndSetters;\n    if (getters)\n      node.getters = getters;\n    if (setters)\n      node.setters = setters;\n  }\n  if (equals === false) {\n    node.equals = nope;\n  } else if (equals) {\n    node.equals = equals;\n  } else if (parent == null ? void 0 : parent.equals) {\n    node.equals = parent.equals;\n  }\n  NODES.set(value, node);\n  return node;\n};\nconst getNodeExisting = (value) => {\n  const node = NODES.get(value);\n  if (!node)\n    throw new Error(\"Impossible\");\n  return node;\n};\nconst getNodeFromStore = (store2) => {\n  return getNodeExisting(getTarget(store2));\n};\nconst getNodeKeys = (node) => {\n  const observable2 = getNodeObservable(node, 0, { equals: false });\n  const keys = new StoreKeys(node, observable2);\n  return keys;\n};\nconst getNodeValues = (node) => {\n  const observable2 = getNodeObservable(node, 0, { equals: false });\n  const values = new StoreValues(node, observable2);\n  return values;\n};\nconst getNodeHas = (node, key, value) => {\n  const observable2 = getNodeObservable(node, value);\n  const has = new StoreHas(node, key, observable2);\n  return has;\n};\nconst getNodeObservable = (node, value, options) => {\n  const observable2 = new Observable(value, options);\n  observable2.signal = node.signal;\n  return observable2;\n};\nconst getNodeProperty = (node, key, value) => {\n  const observable2 = void 0;\n  const propertyNode = isProxiable(value) ? NODES.get(value) || getNode(value, node) : void 0;\n  const property = new StoreProperty(node, key, observable2, propertyNode);\n  node.properties || (node.properties = new StoreMap());\n  node.properties.set(key, property);\n  return property;\n};\nconst getGettersAndSetters = (value) => {\n  if (isArray$1(value))\n    return void 0;\n  let getters;\n  let setters;\n  const keys = Object.keys(value);\n  for (let i = 0, l = keys.length; i < l; i++) {\n    const key = keys[i];\n    const descriptor = Object.getOwnPropertyDescriptor(value, key);\n    if (!descriptor)\n      continue;\n    const { get: get2, set } = descriptor;\n    if (get2) {\n      getters || (getters = new StoreMap());\n      getters.set(key, get2);\n    }\n    if (set) {\n      setters || (setters = new StoreMap());\n      setters.set(key, set);\n    }\n  }\n  if (!getters && !setters)\n    return void 0;\n  return { getters, setters };\n};\nconst getStore = (value, options) => {\n  if (isStore(value))\n    return value;\n  const node = NODES.get(value) || getNode(value, void 0, options == null ? void 0 : options.equals);\n  return node.store;\n};\nconst getTarget = (value) => {\n  if (isStore(value))\n    return value[SYMBOL_STORE_TARGET];\n  return value;\n};\nconst getUntracked = (value) => {\n  if (!isObject$1(value))\n    return value;\n  if (isUntracked(value))\n    return value;\n  return new Proxy(value, STORE_UNTRACK_TRAPS);\n};\nconst isEqualDescriptor = (a, b, equals) => {\n  return !!a.configurable === !!b.configurable && !!a.enumerable === !!b.enumerable && !!a[\"writable\"] === !!b[\"writable\"] && equals(a[\"value\"], b[\"value\"]) && a.get === b.get && a.set === b.set;\n};\nconst isListenable = () => {\n  return TRACKING;\n};\nconst isProxiable = (value) => {\n  if (value === null || typeof value !== \"object\")\n    return false;\n  if (SYMBOL_STORE in value)\n    return true;\n  if (SYMBOL_STORE_UNTRACKED in value)\n    return false;\n  if (isArray$1(value))\n    return true;\n  const prototype = Object.getPrototypeOf(value);\n  if (prototype === null)\n    return true;\n  return Object.getPrototypeOf(prototype) === null;\n};\nconst isUntracked = (value) => {\n  if (value === null || typeof value !== \"object\")\n    return false;\n  return SYMBOL_STORE_UNTRACKED in value;\n};\nconst store = (value, options) => {\n  if (!isObject$1(value))\n    return value;\n  if (isUntracked(value))\n    return value;\n  return getStore(value, options);\n};\nstore.on = (target2, listener) => {\n  const targets = castArray$1(target2);\n  const selectors = targets.filter(isFunction$1);\n  const nodes = targets.filter(isStore).map(getNodeFromStore);\n  StoreListenersRegular.active += 1;\n  const disposers = selectors.map((selector2) => {\n    let inited = false;\n    return reaction(() => {\n      if (inited) {\n        StoreListenersRegular.listeners.add(listener);\n        StoreScheduler.schedule();\n      }\n      inited = true;\n      selector2();\n    });\n  });\n  nodes.forEach((node) => {\n    lazySetAdd(node, \"listenersRegular\", listener);\n  });\n  return () => {\n    StoreListenersRegular.active -= 1;\n    disposers.forEach((disposer) => {\n      disposer();\n    });\n    nodes.forEach((node) => {\n      lazySetDelete(node, \"listenersRegular\", listener);\n    });\n  };\n};\nstore._onRoots = (target2, listener) => {\n  if (!isStore(target2))\n    return noop;\n  const node = getNodeFromStore(target2);\n  if (node.parents)\n    throw new Error(\"Only top-level stores are supported\");\n  StoreListenersRoots.active += 1;\n  lazySetAdd(node, \"listenersRoots\", listener);\n  return () => {\n    StoreListenersRoots.active -= 1;\n    lazySetDelete(node, \"listenersRoots\", listener);\n  };\n};\nstore.reconcile = (() => {\n  const getType = (value) => {\n    if (isArray$1(value))\n      return 1;\n    if (isProxiable(value))\n      return 2;\n    return 0;\n  };\n  const reconcileOuter = (prev, next) => {\n    const uprev = getTarget(prev);\n    const unext = getTarget(next);\n    reconcileInner(prev, next);\n    const prevType = getType(uprev);\n    const nextType = getType(unext);\n    if (prevType === 1 || nextType === 1) {\n      prev.length = next.length;\n    }\n    return prev;\n  };\n  const reconcileInner = (prev, next) => {\n    const uprev = getTarget(prev);\n    const unext = getTarget(next);\n    const prevKeys = Object.keys(uprev);\n    const nextKeys = Object.keys(unext);\n    for (let i = 0, l = nextKeys.length; i < l; i++) {\n      const key = nextKeys[i];\n      const prevValue = uprev[key];\n      const nextValue = unext[key];\n      if (!is(prevValue, nextValue)) {\n        const prevType = getType(prevValue);\n        const nextType = getType(nextValue);\n        if (prevType && prevType === nextType) {\n          reconcileInner(prev[key], nextValue);\n          if (prevType === 1) {\n            prev[key].length = nextValue.length;\n          }\n        } else {\n          prev[key] = nextValue;\n        }\n      } else if (prevValue === void 0 && !(key in uprev)) {\n        prev[key] = void 0;\n      }\n    }\n    for (let i = 0, l = prevKeys.length; i < l; i++) {\n      const key = prevKeys[i];\n      if (!(key in unext)) {\n        delete prev[key];\n      }\n    }\n    return prev;\n  };\n  const reconcile = (prev, next) => {\n    return batch(() => {\n      return untrack(() => {\n        return reconcileOuter(prev, next);\n      });\n    });\n  };\n  return reconcile;\n})();\nstore.untrack = (value) => {\n  return getUntracked(value);\n};\nstore.unwrap = (value) => {\n  return getTarget(value);\n};\nconst suspense = (when, fn) => {\n  const suspense2 = new Suspense();\n  const condition = boolean(when);\n  effect(() => {\n    suspense2.toggle(get(condition));\n  });\n  return suspense2.wrap(fn);\n};\nfunction observable(value, options) {\n  return writable(new Observable(value, options));\n}\nconst tryCatch = (value, fn) => {\n  const observable$1 = observable();\n  return memo(() => {\n    const error$1 = observable$1();\n    if (error$1) {\n      const reset = () => observable$1(void 0);\n      const options = { error: error$1, reset };\n      return resolve(fn(options));\n    } else {\n      error(observable$1);\n      return resolve(value);\n    }\n  });\n};\nconst _with = () => {\n  const owner2 = OWNER;\n  return (fn) => {\n    return owner2.wrap(() => fn());\n  };\n};\nconst CONTEXTS_DATA = /* @__PURE__ */ new WeakMap();\nconst DIRECTIVE_OUTSIDE_SUPER_ROOT = { current: false };\nconst HMR = !!globalThis.VOBY_HMR;\nconst SYMBOL_SUSPENSE = Symbol(\"Suspense\");\nconst SYMBOL_TEMPLATE_ACCESSOR = Symbol(\"Template Accessor\");\nconst SYMBOLS_DIRECTIVES = {};\nconst SYMBOL_CLONE = Symbol(\"CloneElement\");\nconst { assign } = Object;\nconst castArray = (value) => {\n  return isArray(value) ? value : [value];\n};\nconst castError = (exception) => {\n  if (isError(exception))\n    return exception;\n  if (isString(exception))\n    return new Error(exception);\n  return new Error(\"Unknown error\");\n};\nconst flatten = (arr) => {\n  for (let i = 0, l = arr.length; i < l; i++) {\n    if (!isArray(arr[i]))\n      continue;\n    return arr.flat(Infinity);\n  }\n  return arr;\n};\nconst indexOf = (() => {\n  const _indexOf = Array.prototype.indexOf;\n  return (arr, value) => {\n    return _indexOf.call(arr, value);\n  };\n})();\nconst { isArray } = Array;\nconst isBoolean = (value) => {\n  return typeof value === \"boolean\";\n};\nconst isError = (value) => {\n  return value instanceof Error;\n};\nconst isFunction = (value) => {\n  return typeof value === \"function\";\n};\nconst isNil = (value) => {\n  return value === null || value === void 0;\n};\nconst isNode = (value) => {\n  return value instanceof Node;\n};\nconst isObject = (value) => {\n  return typeof value === \"object\" && value !== null;\n};\nconst isPrimitive = (value) => {\n  const t = typeof value;\n  return !(t === \"object\" || t === \"function\");\n};\nconst isPromise = (value) => {\n  return value instanceof Promise;\n};\nconst isProxy = (proxy) => {\n  return proxy == null ? false : !!proxy[Symbol.for(\"__isProxy\")];\n};\nconst isString = (value) => {\n  return typeof value === \"string\";\n};\nconst isSVG = (value) => {\n  return !!value[\"isSVG\"];\n};\nconst isSVGElement = (() => {\n  const svgRe = /^(t(ext$|s)|s[vwy]|g)|^set|tad|ker|p(at|s)|s(to|c$|ca|k)|r(ec|cl)|ew|us|f($|e|s)|cu|n[ei]|l[ty]|[GOP]/;\n  const svgCache = {};\n  return (element) => {\n    const cached = svgCache[element];\n    return cached !== void 0 ? cached : svgCache[element] = !element.includes(\"-\") && svgRe.test(element);\n  };\n})();\nconst isTemplateAccessor = (value) => {\n  return isFunction(value) && SYMBOL_TEMPLATE_ACCESSOR in value;\n};\nconst isTruthy = (value) => {\n  return !!value;\n};\nconst once = (fn) => {\n  let called = false;\n  let result;\n  return () => {\n    if (!called) {\n      called = true;\n      result = fn();\n    }\n    return result;\n  };\n};\nconst fixBigInt = (v) => typeof v === \"bigint\" ? v + \"n\" : v;\nconst toArray = (v) => [...[v].flat(Infinity)];\nconst useMicrotask = (fn) => {\n  const disposed$1 = disposed();\n  const runWithOwner = _with();\n  queueMicrotask(() => {\n    if (disposed$1())\n      return;\n    runWithOwner(fn);\n  });\n};\nconst useMicrotask$1 = useMicrotask;\nexport {\n  isSVG as $,\n  isSVGElement as A,\n  isNode as B,\n  SYMBOL_OBSERVABLE as C,\n  SYMBOL_OBSERVABLE_FROZEN as D,\n  SYMBOL_UNCACHED as E,\n  SYMBOL_UNTRACKED_UNWRAPPED as F,\n  CONTEXTS_DATA as G,\n  DIRECTIVE_OUTSIDE_SUPER_ROOT as H,\n  HMR as I,\n  SYMBOL_SUSPENSE as J,\n  SYMBOL_TEMPLATE_ACCESSOR as K,\n  SYMBOLS_DIRECTIVES as L,\n  indexOf as M,\n  on as N,\n  off as O,\n  isArray as P,\n  fixBigInt as Q,\n  isNil as R,\n  SYMBOL_CLONE as S,\n  flatten as T,\n  castArray as U,\n  SYMBOL_STORE_OBSERVABLE as V,\n  isBoolean as W,\n  isProxy as X,\n  toArray as Y,\n  isTemplateAccessor as Z,\n  context as _,\n  isFunction as a,\n  _with as a0,\n  tryCatch as a1,\n  _for as a2,\n  forIndex as a3,\n  forValue as a4,\n  isTruthy as a5,\n  ternary as a6,\n  suspense as a7,\n  _switch as a8,\n  isPromise as a9,\n  castError as aa,\n  owner as ab,\n  assign as b,\n  isObject as c,\n  boolean as d,\n  cleanup as e,\n  disposed as f,\n  get as g,\n  effect as h,\n  isPrimitive as i,\n  error as j,\n  reaction as k,\n  readonly as l,\n  memo as m,\n  root as n,\n  once as o,\n  observable as p,\n  batch as q,\n  resolve as r,\n  selector as s,\n  isBatching as t,\n  useMicrotask$1 as u,\n  isObservable as v,\n  isStore as w,\n  store as x,\n  untrack as y,\n  isString as z\n};\n//# sourceMappingURL=use_microtask-e694cf95.js.map\n","import { F as SYMBOL_UNTRACKED_UNWRAPPED, S as SYMBOL_CLONE } from \"./use_microtask-e694cf95.js\";\nconst wrapElement = (element) => {\n  element[SYMBOL_UNTRACKED_UNWRAPPED] = true;\n  return element;\n};\nconst wrapElement$1 = wrapElement;\nconst Fragment = ({ children, ...props }) => {\n  return children;\n};\nconst Fragment$1 = Fragment;\nconst wrapCloneElement = (target, component, props) => {\n  target[SYMBOL_CLONE] = { component, props };\n  return target;\n};\nexport {\n  Fragment$1 as F,\n  wrapElement$1 as a,\n  wrapCloneElement as w\n};\n//# sourceMappingURL=wrap_clone_element-e197fd42.js.map\n","import { N as on, y as untrack, e as cleanup, O as off, D as SYMBOL_OBSERVABLE_FROZEN, C as SYMBOL_OBSERVABLE, z as isString, a as isFunction, F as SYMBOL_UNTRACKED_UNWRAPPED, k as reaction, P as isArray, E as SYMBOL_UNCACHED, v as isObservable, g as get, I as HMR, Z as isTemplateAccessor, $ as isSVG, L as SYMBOLS_DIRECTIVES, H as DIRECTIVE_OUTSIDE_SUPER_ROOT, _ as context, u as useMicrotask, R as isNil, T as flatten, U as castArray, x as store, w as isStore, V as SYMBOL_STORE_OBSERVABLE, a0 as _with, W as isBoolean } from \"./use_microtask-e694cf95.js\";\nconst { createComment, createHTMLNode, createSVGNode, createText, createDocumentFragment } = (() => {\n  if (typeof via !== \"undefined\") {\n    const document2 = via.document;\n    const createComment2 = document2.createComment;\n    const createHTMLNode2 = document2.createElement;\n    const createSVGNode2 = (name) => document2.createElementNS(\"http://www.w3.org/2000/svg\", name);\n    const createText2 = document2.createTextNode;\n    const createDocumentFragment2 = document2.createDocumentFragment;\n    return { createComment: createComment2, createHTMLNode: createHTMLNode2, createSVGNode: createSVGNode2, createText: createText2, createDocumentFragment: createDocumentFragment2 };\n  } else {\n    const createComment2 = document.createComment.bind(document, \"\");\n    const createHTMLNode2 = document.createElement.bind(document);\n    const createSVGNode2 = document.createElementNS.bind(document, \"http://www.w3.org/2000/svg\");\n    const createText2 = document.createTextNode.bind(document);\n    const createDocumentFragment2 = document.createDocumentFragment.bind(document);\n    return { createComment: createComment2, createHTMLNode: createHTMLNode2, createSVGNode: createSVGNode2, createText: createText2, createDocumentFragment: createDocumentFragment2 };\n  }\n})();\nconst target = (observable) => SYMBOL_OBSERVABLE_FROZEN in observable ? observable : observable(SYMBOL_OBSERVABLE);\nclass Callable {\n  /* CONSTRUCTOR */\n  constructor(observable) {\n    this.observable = target(observable);\n  }\n  /* API */\n  init(observable) {\n    on(this.observable, this);\n    this.call(observable, untrack(observable));\n    cleanup(this);\n  }\n  call() {\n    if (arguments.length === 1) {\n      this.cleanup();\n    } else {\n      this.update(arguments[1], arguments[2]);\n    }\n  }\n  cleanup() {\n    off(this.observable, this);\n  }\n}\nclass CallableAttributeStatic extends Callable {\n  /* CONSTRUCTOR */\n  constructor(observable, element, key) {\n    super(observable);\n    this.element = element;\n    this.key = key;\n    this.init(observable);\n  }\n  /* API */\n  update(value) {\n    setAttributeStatic(this.element, this.key, value);\n  }\n}\nclass CallableChildStatic extends Callable {\n  /* CONSTRUCTOR */\n  constructor(observable, parent, fragment) {\n    super(observable);\n    this.parent = parent;\n    this.fragment = fragment;\n    this.init(observable);\n  }\n  /* API */\n  update(value) {\n    setChildStatic(this.parent, this.fragment, value, true);\n  }\n}\nclass CallableClassStatic extends Callable {\n  /* CONSTRUCTOR */\n  constructor(observable, element, key) {\n    super(observable);\n    this.element = element;\n    this.key = key;\n    this.init(observable);\n  }\n  /* API */\n  update(value) {\n    setClassStatic(this.element, this.key, value);\n  }\n}\nclass CallableClassBooleanStatic extends Callable {\n  /* CONSTRUCTOR */\n  constructor(observable, element, value) {\n    super(observable);\n    this.element = element;\n    this.value = value;\n    this.init(observable);\n  }\n  /* API */\n  update(key, keyPrev) {\n    setClassBooleanStatic(this.element, this.value, key, keyPrev);\n  }\n}\nclass CallableEventStatic extends Callable {\n  /* CONSTRUCTOR */\n  constructor(observable, element, event) {\n    super(observable);\n    this.element = element;\n    this.event = event;\n    this.init(observable);\n  }\n  /* API */\n  update(value) {\n    setEventStatic(this.element, this.event, value);\n  }\n}\nclass CallablePropertyStatic extends Callable {\n  /* CONSTRUCTOR */\n  constructor(observable, element, key) {\n    super(observable);\n    this.element = element;\n    this.key = key;\n    this.init(observable);\n  }\n  /* API */\n  update(value) {\n    setPropertyStatic(this.element, this.key, value);\n  }\n}\nclass CallableStyleStatic extends Callable {\n  /* CONSTRUCTOR */\n  constructor(observable, element, key) {\n    super(observable);\n    this.element = element;\n    this.key = key;\n    this.init(observable);\n  }\n  /* API */\n  update(value) {\n    setStyleStatic(this.element, this.key, value);\n  }\n}\nclass CallableStylesStatic extends Callable {\n  /* CONSTRUCTOR */\n  constructor(observable, element) {\n    super(observable);\n    this.element = element;\n    this.init(observable);\n  }\n  /* API */\n  update(object, objectPrev) {\n    setStylesStatic(this.element, object, objectPrev);\n  }\n}\nconst classesToggle = (element, classes, force) => {\n  const { className } = element;\n  if (isString(className)) {\n    if (!className) {\n      if (force) {\n        element.className = classes;\n        return;\n      } else {\n        return;\n      }\n    } else if (!force && className === classes) {\n      element.className = \"\";\n      return;\n    }\n  }\n  if (classes.includes(\" \")) {\n    classes.split(\" \").forEach((cls) => {\n      if (!cls.length)\n        return;\n      element.classList.toggle(cls, !!force);\n    });\n  } else {\n    element.classList.toggle(classes, !!force);\n  }\n};\nconst dummyNode = createComment(\"\");\nconst beforeDummyWrapper = [dummyNode];\nconst afterDummyWrapper = [dummyNode];\nconst diff = (parent, before, after, nextSibling) => {\n  if (before === after)\n    return;\n  if (before instanceof Node) {\n    beforeDummyWrapper[0] = before;\n    before = beforeDummyWrapper;\n  }\n  if (after instanceof Node) {\n    afterDummyWrapper[0] = after;\n    after = afterDummyWrapper;\n  }\n  const bLength = after.length;\n  let aEnd = before.length;\n  let bEnd = bLength;\n  let aStart = 0;\n  let bStart = 0;\n  let map = null;\n  let removable;\n  while (aStart < aEnd || bStart < bEnd) {\n    if (aEnd === aStart) {\n      const node = bEnd < bLength ? bStart ? after[bStart - 1].nextSibling : after[bEnd - bStart] : nextSibling;\n      if (bStart < bEnd) {\n        if (node) {\n          node.before.apply(node, after.slice(bStart, bEnd));\n        } else {\n          parent.append.apply(parent, after.slice(bStart, bEnd));\n        }\n        bStart = bEnd;\n      }\n    } else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        if (!map || !map.has(before[aStart])) {\n          removable = before[aStart];\n          parent.removeChild(removable);\n        }\n        aStart++;\n      }\n    } else if (before[aStart] === after[bStart]) {\n      aStart++;\n      bStart++;\n    } else if (before[aEnd - 1] === after[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    } else if (before[aStart] === after[bEnd - 1] && after[bStart] === before[aEnd - 1]) {\n      const node = before[--aEnd].nextSibling;\n      parent.insertBefore(\n        after[bStart++],\n        before[aStart++].nextSibling\n      );\n      parent.insertBefore(after[--bEnd], node);\n      before[aEnd] = after[bEnd];\n    } else {\n      if (!map) {\n        map = /* @__PURE__ */ new Map();\n        let i = bStart;\n        while (i < bEnd)\n          map.set(after[i], i++);\n      }\n      if (map.has(before[aStart])) {\n        const index = map.get(before[aStart]);\n        if (bStart < index && index < bEnd) {\n          let i = aStart;\n          let sequence = 1;\n          while (++i < aEnd && i < bEnd && map.get(before[i]) === index + sequence)\n            sequence++;\n          if (sequence > index - bStart) {\n            const node = before[aStart];\n            if (bStart < index) {\n              if (node) {\n                node.before.apply(node, after.slice(bStart, index));\n              } else {\n                parent.append.apply(parent, after.slice(bStart, index));\n              }\n              bStart = index;\n            }\n          } else {\n            parent.replaceChild(\n              after[bStart++],\n              before[aStart++]\n            );\n          }\n        } else\n          aStart++;\n      } else {\n        removable = before[aStart++];\n        parent.removeChild(removable);\n      }\n    }\n  }\n  beforeDummyWrapper[0] = dummyNode;\n  afterDummyWrapper[0] = dummyNode;\n};\nconst diff$1 = diff;\nconst NOOP_CHILDREN = [];\nconst FragmentUtils = {\n  make: () => {\n    return {\n      values: void 0,\n      length: 0\n    };\n  },\n  makeWithNode: (node) => {\n    return {\n      values: node,\n      length: 1\n    };\n  },\n  makeWithFragment: (fragment) => {\n    return {\n      values: fragment,\n      fragmented: true,\n      length: 1\n    };\n  },\n  getChildrenFragmented: (thiz, children = []) => {\n    const { values, length } = thiz;\n    if (!length)\n      return children;\n    if (values instanceof Array) {\n      for (let i = 0, l = values.length; i < l; i++) {\n        const value = values[i];\n        if (value instanceof Node) {\n          children.push(value);\n        } else {\n          FragmentUtils.getChildrenFragmented(value, children);\n        }\n      }\n    } else {\n      if (values instanceof Node) {\n        children.push(values);\n      } else {\n        FragmentUtils.getChildrenFragmented(values, children);\n      }\n    }\n    return children;\n  },\n  getChildren: (thiz) => {\n    if (!thiz.length)\n      return NOOP_CHILDREN;\n    if (!thiz.fragmented)\n      return thiz.values;\n    if (thiz.length === 1)\n      return FragmentUtils.getChildren(thiz.values);\n    return FragmentUtils.getChildrenFragmented(thiz);\n  },\n  pushFragment: (thiz, fragment) => {\n    FragmentUtils.pushValue(thiz, fragment);\n    thiz.fragmented = true;\n  },\n  pushNode: (thiz, node) => {\n    FragmentUtils.pushValue(thiz, node);\n  },\n  pushValue: (thiz, value) => {\n    const { values, length } = thiz;\n    if (length === 0) {\n      thiz.values = value;\n    } else if (length === 1) {\n      thiz.values = [values, value];\n    } else {\n      values.push(value);\n    }\n    thiz.length += 1;\n  },\n  replaceWithNode: (thiz, node) => {\n    thiz.values = node;\n    delete thiz.fragmented;\n    thiz.length = 1;\n  },\n  replaceWithFragment: (thiz, fragment) => {\n    thiz.values = fragment.values;\n    thiz.fragmented = fragment.fragmented;\n    thiz.length = fragment.length;\n  }\n};\nconst FragmentUtils$1 = FragmentUtils;\nconst resolveChild = (value, setter, _dynamic = false) => {\n  if (isFunction(value)) {\n    if (SYMBOL_UNTRACKED_UNWRAPPED in value || SYMBOL_OBSERVABLE_FROZEN in value)\n      resolveChild(value(), setter, _dynamic);\n    else\n      reaction(() => {\n        resolveChild(value(), setter, true);\n      });\n  } else if (isArray(value)) {\n    const [values, hasObservables] = resolveArraysAndStatics(value);\n    values[SYMBOL_UNCACHED] = value[SYMBOL_UNCACHED];\n    setter(values, hasObservables || _dynamic);\n  } else {\n    setter(value, _dynamic);\n  }\n};\nconst resolveClass = (classes, resolved = {}) => {\n  if (isString(classes)) {\n    classes.split(/\\s+/g).filter(Boolean).filter((cls) => {\n      resolved[cls] = true;\n    });\n  } else if (isFunction(classes)) {\n    resolveClass(classes(), resolved);\n  } else if (isArray(classes)) {\n    classes.forEach((cls) => {\n      resolveClass(cls, resolved);\n    });\n  } else if (classes) {\n    for (const key in classes) {\n      const value = classes[key];\n      const isActive = !!get(value);\n      if (!isActive)\n        continue;\n      resolved[key] = true;\n    }\n  }\n  return resolved;\n};\nconst resolveArraysAndStatics = (() => {\n  const DUMMY_RESOLVED = [];\n  const resolveArraysAndStaticsInner = (values, resolved, hasObservables) => {\n    for (let i = 0, l = values.length; i < l; i++) {\n      const value = values[i];\n      const type = typeof value;\n      if (type === \"string\" || type === \"number\" || type === \"bigint\") {\n        if (resolved === DUMMY_RESOLVED)\n          resolved = values.slice(0, i);\n        resolved.push(createText(value));\n      } else if (type === \"object\" && isArray(value)) {\n        if (resolved === DUMMY_RESOLVED)\n          resolved = values.slice(0, i);\n        hasObservables = resolveArraysAndStaticsInner(value, resolved, hasObservables)[1];\n      } else if (type === \"function\" && isObservable(value)) {\n        if (resolved !== DUMMY_RESOLVED)\n          resolved.push(value);\n        hasObservables = true;\n      } else {\n        if (resolved !== DUMMY_RESOLVED)\n          resolved.push(value);\n      }\n    }\n    if (resolved === DUMMY_RESOLVED)\n      resolved = values;\n    return [resolved, hasObservables];\n  };\n  return (values) => {\n    return resolveArraysAndStaticsInner(values, DUMMY_RESOLVED, false);\n  };\n})();\nconst setAttributeStatic = (() => {\n  const attributesBoolean = /* @__PURE__ */ new Set([\"allowfullscreen\", \"async\", \"autofocus\", \"autoplay\", \"checked\", \"controls\", \"default\", \"disabled\", \"formnovalidate\", \"hidden\", \"indeterminate\", \"ismap\", \"loop\", \"multiple\", \"muted\", \"nomodule\", \"novalidate\", \"open\", \"playsinline\", \"readonly\", \"required\", \"reversed\", \"seamless\", \"selected\"]);\n  const attributeCamelCasedRe = /e(r[HRWrv]|[Vawy])|Con|l(e[Tcs]|c)|s(eP|y)|a(t[rt]|u|v)|Of|Ex|f[XYa]|gt|hR|d[Pg]|t[TXYd]|[UZq]/;\n  const attributesCache = {};\n  const uppercaseRe = /[A-Z]/g;\n  const normalizeKeySvg = (key) => {\n    return attributesCache[key] || (attributesCache[key] = attributeCamelCasedRe.test(key) ? key : key.replace(uppercaseRe, (char) => `-${char.toLowerCase()}`));\n  };\n  return (element, key, value) => {\n    if (isSVG(element)) {\n      key = key === \"xlinkHref\" || key === \"xlink:href\" ? \"href\" : normalizeKeySvg(key);\n      if (isNil(value) || value === false && attributesBoolean.has(key)) {\n        element.removeAttribute(key);\n      } else {\n        element.setAttribute(key, String(value));\n      }\n    } else {\n      if (isNil(value) || value === false && attributesBoolean.has(key)) {\n        element.removeAttribute(key);\n      } else {\n        value = value === true ? \"\" : String(value);\n        element.setAttribute(key, value);\n      }\n    }\n  };\n})();\nconst setAttribute = (element, key, value) => {\n  if (isFunction(value)) {\n    if (isObservable(value)) {\n      new CallableAttributeStatic(value, element, key);\n    } else {\n      reaction(() => {\n        setAttributeStatic(element, key, value());\n      });\n    }\n  } else {\n    setAttributeStatic(element, key, value);\n  }\n};\nconst setChildReplacementFunction = (parent, fragment, child) => {\n  if (isObservable(child)) {\n    new CallableChildStatic(child, parent, fragment);\n  } else {\n    reaction(() => {\n      let valueNext = child();\n      while (isFunction(valueNext)) {\n        valueNext = valueNext();\n      }\n      setChildStatic(parent, fragment, valueNext, true);\n    });\n  }\n};\nconst setChildReplacementText = (child, childPrev) => {\n  if (childPrev.nodeType === 3) {\n    childPrev.nodeValue = child;\n    return childPrev;\n  } else {\n    const parent = childPrev.parentElement;\n    if (!parent)\n      throw new Error(\"Invalid child replacement\");\n    const textNode = createText(child);\n    parent.replaceChild(textNode, childPrev);\n    return textNode;\n  }\n};\nconst setChildReplacement = (child, childPrev) => {\n  const type = typeof child;\n  if (type === \"string\" || type === \"number\" || type === \"bigint\") {\n    setChildReplacementText(String(child), childPrev);\n  } else {\n    const parent = childPrev.parentElement;\n    if (!parent)\n      throw new Error(\"Invalid child replacement\");\n    const fragment = FragmentUtils$1.makeWithNode(childPrev);\n    if (type === \"function\") {\n      setChildReplacementFunction(parent, fragment, child);\n    } else {\n      setChild(parent, child, fragment);\n    }\n  }\n};\nconst setChildStatic = (parent, fragment, child, dynamic) => {\n  if (!dynamic && child === void 0)\n    return;\n  const prev = FragmentUtils$1.getChildren(fragment);\n  const prevIsArray = prev instanceof Array;\n  const prevLength = prevIsArray ? prev.length : 1;\n  const prevFirst = prevIsArray ? prev[0] : prev;\n  const prevLast = prevIsArray ? prev[prevLength - 1] : prev;\n  const prevSibling = (prevLast == null ? void 0 : prevLast.nextSibling) || null;\n  if (prevLength === 0) {\n    const type = typeof child;\n    if (type === \"string\" || type === \"number\" || type === \"bigint\") {\n      const textNode = createText(child);\n      parent.appendChild(textNode);\n      FragmentUtils$1.replaceWithNode(fragment, textNode);\n      return;\n    } else if (type === \"object\" && child !== null && typeof child.nodeType === \"number\") {\n      const node = child;\n      parent.insertBefore(node, null);\n      FragmentUtils$1.replaceWithNode(fragment, node);\n      return;\n    }\n  }\n  if (prevLength === 1) {\n    const type = typeof child;\n    if (type === \"string\" || type === \"number\" || type === \"bigint\") {\n      const node = setChildReplacementText(String(child), prevFirst);\n      FragmentUtils$1.replaceWithNode(fragment, node);\n      return;\n    }\n  }\n  const fragmentNext = FragmentUtils$1.make();\n  const children = Array.isArray(child) ? child : [child];\n  let nextHasStaticChildren = false;\n  for (let i = 0, l = children.length; i < l; i++) {\n    const child2 = children[i];\n    const type = typeof child2;\n    if (type === \"string\" || type === \"number\" || type === \"bigint\") {\n      nextHasStaticChildren = true;\n      FragmentUtils$1.pushNode(fragmentNext, createText(child2));\n    } else if (type === \"object\" && child2 !== null && typeof child2.nodeType === \"number\") {\n      nextHasStaticChildren = true;\n      FragmentUtils$1.pushNode(fragmentNext, child2);\n    } else if (type === \"function\") {\n      const fragment2 = FragmentUtils$1.make();\n      FragmentUtils$1.pushFragment(fragmentNext, fragment2);\n      resolveChild(child2, setChildStatic.bind(void 0, parent, fragment2));\n    }\n  }\n  let next = FragmentUtils$1.getChildren(fragmentNext);\n  let nextLength = fragmentNext.length;\n  let nextHasDynamicChildren = !nextHasStaticChildren && nextLength > 0;\n  if (nextLength === 0 && prevLength === 1 && prevFirst.nodeType === 8) {\n    return;\n  }\n  if (nextLength === 0 || prevLength === 1 && prevFirst.nodeType === 8 || children[SYMBOL_UNCACHED]) {\n    const { childNodes } = parent;\n    if (childNodes.length === prevLength) {\n      parent.textContent = \"\";\n      if (nextLength === 0) {\n        const placeholder = createComment(\"\");\n        FragmentUtils$1.pushNode(fragmentNext, placeholder);\n        if (next !== fragmentNext.values) {\n          next = placeholder;\n          nextLength += 1;\n        }\n      }\n      if (prevSibling) {\n        if (next instanceof Array) {\n          prevSibling.before.apply(prevSibling, next);\n        } else {\n          parent.insertBefore(next, prevSibling);\n        }\n      } else {\n        if (next instanceof Array) {\n          parent.append.apply(parent, next);\n        } else {\n          parent.append(next);\n        }\n      }\n      FragmentUtils$1.replaceWithFragment(fragment, fragmentNext);\n      return;\n    }\n  }\n  if (nextLength === 0) {\n    const placeholder = createComment(\"\");\n    FragmentUtils$1.pushNode(fragmentNext, placeholder);\n    if (next !== fragmentNext.values) {\n      next = placeholder;\n      nextLength += 1;\n    }\n  }\n  if (prevLength > 0 || nextHasStaticChildren || !nextHasDynamicChildren) {\n    try {\n      diff$1(parent, prev, next, prevSibling);\n    } catch (error) {\n      if (HMR) {\n        console.error(error);\n      } else {\n        throw error;\n      }\n    }\n  }\n  FragmentUtils$1.replaceWithFragment(fragment, fragmentNext);\n};\nconst setChild = (parent, child, fragment = FragmentUtils$1.make()) => {\n  resolveChild(child, setChildStatic.bind(void 0, parent, fragment));\n};\nconst setClassStatic = classesToggle;\nconst setClass = (element, key, value) => {\n  if (isFunction(value)) {\n    if (isObservable(value)) {\n      new CallableClassStatic(value, element, key);\n    } else {\n      reaction(() => {\n        setClassStatic(element, key, value());\n      });\n    }\n  } else {\n    setClassStatic(element, key, value);\n  }\n};\nconst setClassBooleanStatic = (element, value, key, keyPrev) => {\n  if (keyPrev && keyPrev !== true) {\n    setClassStatic(element, keyPrev, false);\n  }\n  if (key && key !== true) {\n    setClassStatic(element, key, value);\n  }\n};\nconst setClassBoolean = (element, value, key) => {\n  if (isFunction(key)) {\n    if (isObservable(key)) {\n      new CallableClassBooleanStatic(key, element, value);\n    } else {\n      let keyPrev;\n      reaction(() => {\n        const keyNext = key();\n        setClassBooleanStatic(element, value, keyNext, keyPrev);\n        keyPrev = keyNext;\n      });\n    }\n  } else {\n    setClassBooleanStatic(element, value, key);\n  }\n};\nconst setClassesStatic = (element, object, objectPrev) => {\n  if (isString(object)) {\n    if (isSVG(element)) {\n      element.setAttribute(\"class\", object);\n    } else {\n      element.className = object;\n    }\n  } else {\n    if (objectPrev) {\n      if (isString(objectPrev)) {\n        if (objectPrev) {\n          if (isSVG(element)) {\n            element.setAttribute(\"class\", \"\");\n          } else {\n            element.className = \"\";\n          }\n        }\n      } else if (isArray(objectPrev)) {\n        objectPrev = store.unwrap(objectPrev);\n        for (let i = 0, l = objectPrev.length; i < l; i++) {\n          if (!objectPrev[i])\n            continue;\n          setClassBoolean(element, false, objectPrev[i]);\n        }\n      } else {\n        objectPrev = store.unwrap(objectPrev);\n        for (const key in objectPrev) {\n          if (object && key in object)\n            continue;\n          setClass(element, key, false);\n        }\n      }\n    }\n    if (isArray(object)) {\n      if (isStore(object)) {\n        for (let i = 0, l = object.length; i < l; i++) {\n          const fn = untrack(() => isFunction(object[i]) ? object[i] : object[SYMBOL_STORE_OBSERVABLE](String(i)));\n          setClassBoolean(element, true, fn);\n        }\n      } else {\n        for (let i = 0, l = object.length; i < l; i++) {\n          if (!object[i])\n            continue;\n          setClassBoolean(element, true, object[i]);\n        }\n      }\n    } else {\n      if (isStore(object)) {\n        for (const key in object) {\n          const fn = untrack(() => isFunction(object[key]) ? object[key] : object[SYMBOL_STORE_OBSERVABLE](key));\n          setClass(element, key, fn);\n        }\n      } else {\n        for (const key in object) {\n          setClass(element, key, object[key]);\n        }\n      }\n    }\n  }\n};\nconst setClasses = (element, object) => {\n  if (isFunction(object) || isArray(object)) {\n    let objectPrev;\n    reaction(() => {\n      const objectNext = resolveClass(object);\n      setClassesStatic(element, objectNext, objectPrev);\n      objectPrev = objectNext;\n    });\n  } else {\n    setClassesStatic(element, object);\n  }\n};\nconst setDirective = (() => {\n  const runWithSuperRoot = _with();\n  return (element, directive, args) => {\n    const symbol = SYMBOLS_DIRECTIVES[directive] || Symbol();\n    const data = DIRECTIVE_OUTSIDE_SUPER_ROOT.current ? context(symbol) : runWithSuperRoot(() => context(symbol));\n    if (!data)\n      throw new Error(`Directive \"${directive}\" not found`);\n    const call = () => data.fn(element, ...castArray(args));\n    if (data.immediate) {\n      call();\n    } else {\n      useMicrotask(call);\n    }\n  };\n})();\nconst setEventStatic = (() => {\n  const delegatedEvents = {\n    onauxclick: [\"_onauxclick\", false],\n    onbeforeinput: [\"_onbeforeinput\", false],\n    onclick: [\"_onclick\", false],\n    ondblclick: [\"_ondblclick\", false],\n    onfocusin: [\"_onfocusin\", false],\n    onfocusout: [\"_onfocusout\", false],\n    oninput: [\"_oninput\", false],\n    onkeydown: [\"_onkeydown\", false],\n    onkeyup: [\"_onkeyup\", false],\n    onmousedown: [\"_onmousedown\", false],\n    onmouseup: [\"_onmouseup\", false]\n  };\n  const delegate = (event) => {\n    const key = `_${event}`;\n    document.addEventListener(event.slice(2), (event2) => {\n      const targets = event2.composedPath();\n      let target2 = null;\n      Object.defineProperty(event2, \"currentTarget\", {\n        configurable: true,\n        get() {\n          return target2;\n        }\n      });\n      for (let i = 0, l = targets.length; i < l; i++) {\n        target2 = targets[i];\n        const handler = target2[key];\n        if (!handler)\n          continue;\n        handler(event2);\n        if (event2.cancelBubble)\n          break;\n      }\n      target2 = null;\n    });\n  };\n  return (element, event, value) => {\n    const delegated = delegatedEvents[event];\n    if (delegated) {\n      if (!delegated[1]) {\n        delegated[1] = true;\n        delegate(event);\n      }\n      element[delegated[0]] = value;\n    } else if (event.endsWith(\"passive\")) {\n      const isCapture = event.endsWith(\"capturepassive\");\n      const type = event.slice(2, -7 - (isCapture ? 7 : 0));\n      const key = `_${event}`;\n      const valuePrev = element[key];\n      if (valuePrev)\n        element.removeEventListener(type, valuePrev, { capture: isCapture });\n      if (value)\n        element.addEventListener(type, value, { passive: true, capture: isCapture });\n      element[key] = value;\n    } else if (event.endsWith(\"capture\")) {\n      const type = event.slice(2, -7);\n      const key = `_${event}`;\n      const valuePrev = element[key];\n      if (valuePrev)\n        element.removeEventListener(type, valuePrev, { capture: true });\n      if (value)\n        element.addEventListener(type, value, { capture: true });\n      element[key] = value;\n    } else {\n      element[event] = value;\n    }\n  };\n})();\nconst setEvent = (element, event, value) => {\n  if (isObservable(value)) {\n    new CallableEventStatic(value, element, event);\n  } else {\n    setEventStatic(element, event, value);\n  }\n};\nconst setHTMLStatic = (element, value) => {\n  element.innerHTML = String(isNil(value) ? \"\" : value);\n};\nconst setHTML = (element, value) => {\n  reaction(() => {\n    setHTMLStatic(element, get(get(value).__html));\n  });\n};\nconst setPropertyStatic = (element, key, value) => {\n  if (key === \"tabIndex\" && isBoolean(value)) {\n    value = value ? 0 : void 0;\n  }\n  if (key === \"value\" && element.tagName === \"SELECT\" && !element[\"_$inited\"]) {\n    element[\"_$inited\"] = true;\n    queueMicrotask(() => element[key] = value);\n  }\n  element[key] = value;\n  if (isNil(value)) {\n    setAttributeStatic(element, key, null);\n  }\n};\nconst setProperty = (element, key, value) => {\n  if (isFunction(value)) {\n    if (isObservable(value)) {\n      new CallablePropertyStatic(value, element, key);\n    } else {\n      reaction(() => {\n        setPropertyStatic(element, key, value());\n      });\n    }\n  } else {\n    setPropertyStatic(element, key, value);\n  }\n};\nconst setRef = (element, value) => {\n  if (isNil(value))\n    return;\n  const values = flatten(castArray(value));\n  useMicrotask(() => values.forEach((value2) => value2 == null ? void 0 : value2(element)));\n};\nconst setStyleStatic = (() => {\n  const propertyNonDimensionalRe = /^(-|f[lo].*[^se]$|g.{5,}[^ps]$|z|o[pr]|(W.{5})?[lL]i.*(t|mp)$|an|(bo|s).{4}Im|sca|m.{6}[ds]|ta|c.*[st]$|wido|ini)/i;\n  const propertyNonDimensionalCache = {};\n  return (element, key, value) => {\n    if (key.charCodeAt(0) === 45) {\n      if (isNil(value)) {\n        element.style.removeProperty(key);\n      } else {\n        element.style.setProperty(key, String(value));\n      }\n    } else if (isNil(value)) {\n      element.style[key] = null;\n    } else {\n      element.style[key] = isString(value) || (propertyNonDimensionalCache[key] || (propertyNonDimensionalCache[key] = propertyNonDimensionalRe.test(key))) ? value : `${value}px`;\n    }\n  };\n})();\nconst setStyle = (element, key, value) => {\n  if (isFunction(value)) {\n    if (isObservable(value)) {\n      new CallableStyleStatic(value, element, key);\n    } else {\n      reaction(() => {\n        setStyleStatic(element, key, value());\n      });\n    }\n  } else {\n    setStyleStatic(element, key, value);\n  }\n};\nconst setStylesStatic = (element, object, objectPrev) => {\n  if (isString(object)) {\n    element.setAttribute(\"style\", object);\n  } else {\n    if (objectPrev) {\n      if (isString(objectPrev)) {\n        if (objectPrev) {\n          element.style.cssText = \"\";\n        }\n      } else {\n        objectPrev = store.unwrap(objectPrev);\n        for (const key in objectPrev) {\n          if (object && key in object)\n            continue;\n          setStyleStatic(element, key, null);\n        }\n      }\n    }\n    if (isStore(object)) {\n      for (const key in object) {\n        const fn = untrack(() => isFunction(object[key]) ? object[key] : object[SYMBOL_STORE_OBSERVABLE](key));\n        setStyle(element, key, fn);\n      }\n    } else {\n      for (const key in object) {\n        setStyle(element, key, object[key]);\n      }\n    }\n  }\n};\nconst setStyles = (element, object) => {\n  if (isFunction(object)) {\n    if (isObservable(object)) {\n      new CallableStylesStatic(object, element);\n    } else {\n      let objectPrev;\n      reaction(() => {\n        const objectNext = object();\n        setStylesStatic(element, objectNext, objectPrev);\n        objectPrev = objectNext;\n      });\n    }\n  } else {\n    setStylesStatic(element, object);\n  }\n};\nconst setTemplateAccessor = (element, key, value) => {\n  if (key === \"children\") {\n    const placeholder = createText(\"\");\n    element.insertBefore(placeholder, null);\n    value(element, \"setChildReplacement\", void 0, placeholder);\n  } else if (key === \"ref\") {\n    value(element, \"setRef\");\n  } else if (key === \"style\") {\n    value(element, \"setStyles\");\n  } else if (key === \"class\" || key === \"className\") {\n    if (!isSVG(element)) {\n      element.className = \"\";\n    }\n    value(element, \"setClasses\");\n  } else if (key === \"dangerouslySetInnerHTML\") {\n    value(element, \"setHTML\");\n  } else if (key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110) {\n    value(element, \"setEvent\", key.toLowerCase());\n  } else if (key.charCodeAt(0) === 117 && key.charCodeAt(3) === 58) {\n    value(element, \"setDirective\", key.slice(4));\n  } else if (key === \"innerHTML\" || key === \"outerHTML\" || key === \"textContent\")\n    ;\n  else if (key in element && !isSVG(element)) {\n    value(element, \"setProperty\", key);\n  } else {\n    element.setAttribute(key, \"\");\n    value(element, \"setAttribute\", key);\n  }\n};\nconst setProp = (element, key, value) => {\n  if (isTemplateAccessor(value)) {\n    setTemplateAccessor(element, key, value);\n  } else if (key === \"children\") {\n    setChild(element, value);\n  } else if (key === \"ref\") {\n    setRef(element, value);\n  } else if (key === \"style\") {\n    setStyles(element, value);\n  } else if (key === \"class\" || key === \"className\") {\n    setClasses(element, value);\n  } else if (key === \"dangerouslySetInnerHTML\") {\n    setHTML(element, value);\n  } else if (key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110) {\n    setEvent(element, key.toLowerCase(), value);\n  } else if (key.charCodeAt(0) === 117 && key.charCodeAt(3) === 58) {\n    setDirective(element, key.slice(4), value);\n  } else if (key === \"innerHTML\" || key === \"outerHTML\" || key === \"textContent\")\n    ;\n  else if (key in element && !isSVG(element)) {\n    setProperty(element, key, value);\n  } else {\n    setAttribute(element, key, value);\n  }\n};\nconst setProps = (element, object) => {\n  for (const key in object) {\n    setProp(element, key, object[key]);\n  }\n};\nexport {\n  createHTMLNode as a,\n  setAttribute as b,\n  createSVGNode as c,\n  setChildReplacement as d,\n  setClasses as e,\n  setEvent as f,\n  setHTML as g,\n  setProperty as h,\n  setRef as i,\n  setStyles as j,\n  createText as k,\n  classesToggle as l,\n  setChild as m,\n  setProps as s\n};\n//# sourceMappingURL=setters-3e914440.js.map\n","import { a as wrapElement, w as wrapCloneElement } from \"./wrap_clone_element-e197fd42.js\";\nimport { s as setProps, c as createSVGNode, a as createHTMLNode } from \"./setters-3e914440.js\";\nimport { a as isFunction, z as isString, A as isSVGElement, B as isNode, y as untrack } from \"./use_microtask-e694cf95.js\";\nconst createElement = (component, props, _key, _isStatic, _source, _self) => {\n  const { ...rest } = props;\n  if (isFunction(component)) {\n    const props2 = rest;\n    return wrapElement(() => {\n      return untrack(() => component.call(component, props2));\n    });\n  } else if (isString(component)) {\n    const props2 = rest;\n    const isSVG = isSVGElement(component);\n    const createNode = isSVG ? createSVGNode : createHTMLNode;\n    return wrapElement(() => {\n      const child = createNode(component);\n      if (isSVG)\n        child[\"isSVG\"] = true;\n      untrack(() => setProps(child, props2));\n      return child;\n    });\n  } else if (isNode(component)) {\n    return wrapElement(() => component);\n  } else {\n    throw new Error(\"Invalid component\");\n  }\n};\nconst creatElement = createElement;\nconst jsx = (component, props, key) => {\n  return wrapCloneElement(creatElement(component, props), component, props);\n};\nconst jsxDEV = (component, props, key, isStatic, source, self) => {\n  return wrapCloneElement(creatElement(component, props), component, props);\n};\nexport {\n  jsxDEV as a,\n  creatElement as c,\n  jsx as j\n};\n//# sourceMappingURL=jsx-runtime-742b912a.js.map\n","export const extend = Object.assign\r\n//     || (<T extends {}, S extends {}>(target: T, source: S) => {\r\n//     for (var key in source) {\r\n//         if (source.hasOwnProperty(key))\r\n//             target[key as any] = source[key]\r\n//     }\r\n//     return target\r\n// })\r\nexport const prefixed = (prop: string) => {\r\n    let style = document.createElement(\"div\").style\r\n    let vendors = [\"Webkit\", \"Moz\", \"ms\", \"O\"]\r\n    let name: string\r\n\r\n    if (prop in style) return prop\r\n\r\n    for (var i = 0, len = vendors.length; i < len; i++) {\r\n        name = vendors[i] + prop.charAt(0).toUpperCase() + prop.substring(1)\r\n        if (name in style) return name\r\n    }\r\n\r\n    return null\r\n}\r\nexport const getStyle = (el: Element, prop: string) => {\r\n    prop = prop.replace(/([A-Z])/g, \"-$1\")\r\n    prop = prop.toLowerCase()\r\n    return window.getComputedStyle(el, null).getPropertyValue(prop)\r\n}\r\n\r\nexport const isArray = Array.isArray || ((obj: Function) => {\r\n    return Object.prototype.toString.call(obj) === \"[object Array]\"\r\n}\r\n)","import { a1 as tryCatch, y as untrack, a as isFunction, a2 as _for, a3 as forIndex, a4 as forValue, p as observable, k as reaction, R as isNil, a5 as isTruthy, a6 as ternary, m as memo, _ as context, J as SYMBOL_SUSPENSE, g as get, a7 as suspense, r as resolve, U as castArray, a8 as _switch, b as assign, P as isArray, v as isObservable, e as cleanup, G as CONTEXTS_DATA, f as disposed, l as readonly, a9 as isPromise, q as batch, aa as castError, L as SYMBOLS_DIRECTIVES, H as DIRECTIVE_OUTSIDE_SUPER_ROOT, ab as owner } from \"./use_microtask-e694cf95.js\";\nconst ErrorBoundary = ({ fallback, children }) => {\n  return tryCatch(children, (props) => untrack(() => isFunction(fallback) ? fallback(props) : fallback));\n};\nconst ErrorBoundary$1 = ErrorBoundary;\nconst For = ({ values, fallback, children }) => {\n  return _for(values, children, fallback);\n};\nconst For$1 = For;\nconst ForIndex = ({ values, fallback, children }) => {\n  return forIndex(values, children, fallback);\n};\nconst ForIndex$1 = ForIndex;\nconst ForValue = ({ values, fallback, children }) => {\n  return forValue(values, children, fallback);\n};\nconst ForValue$1 = ForValue;\nconst useGuarded = (value, guard) => {\n  const guarded = observable();\n  reaction(() => {\n    const current = isFunction(value) ? value() : value;\n    if (!guard(current))\n      return;\n    guarded(() => current);\n  });\n  return () => {\n    const current = guarded();\n    if (isNil(current))\n      throw new Error(\"The value never passed the type guard\");\n    return current;\n  };\n};\nconst useGuarded$1 = useGuarded;\nconst useTruthy = (value) => {\n  return useGuarded$1(value, isTruthy);\n};\nconst useTruthy$1 = useTruthy;\nconst If = ({ when, fallback, children }) => {\n  if (isFunction(children) && children.length) {\n    const truthy = useTruthy$1(when);\n    return ternary(when, () => untrack(() => children(truthy)), fallback);\n  } else {\n    return ternary(when, () => untrack(children), fallback);\n  }\n};\nconst If$1 = If;\nconst SuspenseContext = {\n  new: () => {\n    const data = SuspenseContext.create();\n    SuspenseContext.set(data);\n    return data;\n  },\n  create: () => {\n    const parent = SuspenseContext.get();\n    const count = observable(0);\n    const active = memo(() => !!count());\n    const increment = (nr = 1) => {\n      parent == null ? void 0 : parent.increment(nr);\n      count((prev) => prev + nr);\n    };\n    const decrement = (nr = -1) => queueMicrotask(() => {\n      parent == null ? void 0 : parent.decrement(nr);\n      count((prev) => prev + nr);\n    });\n    const data = { active, increment, decrement };\n    return data;\n  },\n  get: () => {\n    return context(SYMBOL_SUSPENSE);\n  },\n  set: (data) => {\n    return context(SYMBOL_SUSPENSE, data);\n  }\n};\nconst SuspenseContext$1 = SuspenseContext;\nconst Suspense = ({ when, fallback, children }) => {\n  return memo(() => {\n    const suspense$1 = SuspenseContext$1.new();\n    const condition = memo(() => !!get(when) || suspense$1.active());\n    const childrenSuspended = suspense(condition, () => resolve(children));\n    return ternary(condition, fallback, childrenSuspended);\n  });\n};\nconst Suspense$1 = Suspense;\nconst Switch = ({ when, fallback, children }) => {\n  const childrenWithValues = castArray(children);\n  const values = childrenWithValues.map((child) => child().metadata);\n  return _switch(when, values, fallback);\n};\nSwitch.Case = ({ when, children }) => {\n  const metadata = { metadata: [when, children] };\n  return assign(() => children, metadata);\n};\nSwitch.Default = ({ children }) => {\n  const metadata = { metadata: [children] };\n  return assign(() => children, metadata);\n};\nconst Switch$1 = Switch;\nconst Ternary = ({ when, children }) => {\n  return ternary(when, children[0], children[1]);\n};\nconst Ternary$1 = Ternary;\nfunction useResolved(values, callback, resolveFunction) {\n  const isResolvable = resolveFunction !== false && callback !== false ? isFunction : isObservable;\n  const resolve2 = (value) => isResolvable(value) ? value() : value;\n  if (isArray(values)) {\n    const resolved = values.map(resolve2);\n    if (isFunction(callback)) {\n      return callback.apply(void 0, resolved);\n    } else {\n      return resolved;\n    }\n  } else {\n    const resolved = resolve2(values);\n    if (isFunction(callback)) {\n      return callback(resolved);\n    } else {\n      return resolved;\n    }\n  }\n}\nfunction useEventListener(target, event, handler, options) {\n  return reaction(() => {\n    const fn = get(handler, false);\n    return useResolved([target, event, options], (target2, event2, options2) => {\n      const targets = castArray(target2);\n      targets.forEach((target3) => {\n        target3 == null ? void 0 : target3.addEventListener(event2, fn, options2);\n      });\n      return () => {\n        targets.forEach((target3) => {\n          target3 == null ? void 0 : target3.removeEventListener(event2, fn, options2);\n        });\n      };\n    });\n  });\n}\nconst useAbortController = (signals = []) => {\n  signals = castArray(signals);\n  const controller = new AbortController();\n  const abort = controller.abort.bind(controller);\n  const aborted = signals.some((signal) => signal.aborted);\n  if (aborted) {\n    abort();\n  } else {\n    signals.forEach((signal) => useEventListener(signal, \"abort\", abort));\n    cleanup(abort);\n  }\n  return controller;\n};\nconst useAbortController$1 = useAbortController;\nconst useAbortSignal = (signals = []) => {\n  return useAbortController$1(signals).signal;\n};\nconst useAbortSignal$1 = useAbortSignal;\nconst useScheduler = ({ loop, callback, cancel, schedule }) => {\n  let tickId;\n  const work = (value) => {\n    if (get(loop))\n      tick();\n    get(callback, false)(value);\n  };\n  const tick = () => {\n    tickId = untrack(() => schedule(work));\n  };\n  const dispose = () => {\n    untrack(() => cancel(tickId));\n  };\n  tick();\n  cleanup(dispose);\n  return dispose;\n};\nconst useScheduler$1 = useScheduler;\nconst useAnimationFrame = (callback) => {\n  return useScheduler$1({\n    callback,\n    cancel: cancelAnimationFrame,\n    schedule: requestAnimationFrame\n  });\n};\nconst useAnimationFrame$1 = useAnimationFrame;\nconst useAnimationLoop = (callback) => {\n  return useScheduler$1({\n    callback,\n    loop: true,\n    cancel: cancelAnimationFrame,\n    schedule: requestAnimationFrame\n  });\n};\nconst useAnimationLoop$1 = useAnimationLoop;\nfunction useContext(Context) {\n  const { symbol, defaultValue } = CONTEXTS_DATA.get(Context) || { symbol: Symbol() };\n  const valueContext = context(symbol);\n  const value = isNil(valueContext) ? defaultValue : valueContext;\n  return value;\n}\nclass SuspenseManager {\n  constructor() {\n    this.suspenses = /* @__PURE__ */ new Map();\n    this.change = (suspense2, nr) => {\n      const counter = this.suspenses.get(suspense2) || 0;\n      const counterNext = Math.max(0, counter + nr);\n      if (counter === counterNext)\n        return;\n      if (counterNext) {\n        this.suspenses.set(suspense2, counterNext);\n      } else {\n        this.suspenses.delete(suspense2);\n      }\n      if (nr > 0) {\n        suspense2.increment(nr);\n      } else {\n        suspense2.decrement(nr);\n      }\n    };\n    this.suspend = () => {\n      const suspense2 = SuspenseContext$1.get();\n      if (!suspense2)\n        return;\n      this.change(suspense2, 1);\n      cleanup(() => {\n        this.change(suspense2, -1);\n      });\n    };\n    this.unsuspend = () => {\n      this.suspenses.forEach((counter, suspense2) => {\n        this.change(suspense2, -counter);\n      });\n    };\n  }\n}\nconst SuspenseManager$1 = SuspenseManager;\nconst useResource = (fetcher) => {\n  const pending = observable(true);\n  const error = observable();\n  const value = observable();\n  const latest = observable();\n  const { suspend, unsuspend } = new SuspenseManager$1();\n  const resourcePending = { pending: true, get value() {\n    return void suspend();\n  }, get latest() {\n    return latest() ?? void suspend();\n  } };\n  const resourceRejected = { pending: false, get error() {\n    return error();\n  }, get value() {\n    throw error();\n  }, get latest() {\n    throw error();\n  } };\n  const resourceResolved = { pending: false, get value() {\n    return value();\n  }, get latest() {\n    return value();\n  } };\n  const resourceFunction = { pending: () => pending(), error: () => error(), value: () => resource().value, latest: () => resource().latest };\n  const resource = observable(resourcePending);\n  reaction(() => {\n    const disposed$1 = disposed();\n    const onPending = () => {\n      batch(() => {\n        pending(true);\n        error(void 0);\n        value(void 0);\n        resource(resourcePending);\n      });\n    };\n    const onResolve = (result) => {\n      if (disposed$1())\n        return;\n      batch(() => {\n        pending(false);\n        error(void 0);\n        value(() => result);\n        latest(() => result);\n        resource(resourceResolved);\n      });\n    };\n    const onReject = (exception) => {\n      if (disposed$1())\n        return;\n      batch(() => {\n        pending(false);\n        error(castError(exception));\n        value(void 0);\n        latest(void 0);\n        resource(resourceRejected);\n      });\n    };\n    const fetch2 = () => {\n      try {\n        const value2 = get(fetcher());\n        if (isPromise(value2)) {\n          onPending();\n          value2.then(onResolve, onReject);\n          value2.then(unsuspend, unsuspend);\n        } else {\n          onResolve(value2);\n        }\n      } catch (error2) {\n        onReject(error2);\n      }\n    };\n    fetch2();\n  });\n  return assign(readonly(resource), resourceFunction);\n};\nconst useResource$1 = useResource;\nconst useFetch = (request, init) => {\n  return useResource$1(() => {\n    return useResolved([request, init], (request2, init2 = {}) => {\n      const signal = useAbortSignal$1(init2.signal || []);\n      init2.signal = signal;\n      return fetch(request2, init2);\n    });\n  });\n};\nconst useFetch$1 = useFetch;\nconst useIdleCallback = (callback, options) => {\n  return useScheduler$1({\n    callback,\n    cancel: cancelIdleCallback,\n    schedule: (callback2) => requestIdleCallback(callback2, get(options))\n  });\n};\nconst useIdleCallback$1 = useIdleCallback;\nconst useIdleLoop = (callback, options) => {\n  return useScheduler$1({\n    callback,\n    loop: true,\n    cancel: cancelIdleCallback,\n    schedule: (callback2) => requestIdleCallback(callback2, get(options))\n  });\n};\nconst useIdleLoop$1 = useIdleLoop;\nconst useInterval = (callback, ms) => {\n  return useScheduler$1({\n    callback,\n    cancel: clearInterval,\n    schedule: (callback2) => setInterval(callback2, get(ms))\n  });\n};\nconst useInterval$1 = useInterval;\nconst usePromise = (promise) => {\n  return useResource$1(() => get(promise));\n};\nconst usePromise$1 = usePromise;\nconst useTimeout = (callback, ms) => {\n  return useScheduler$1({\n    callback,\n    cancel: clearTimeout,\n    schedule: (callback2) => setTimeout(callback2, get(ms))\n  });\n};\nconst useTimeout$1 = useTimeout;\nfunction createContext(defaultValue) {\n  const symbol = Symbol();\n  const Provider = ({ value, children }) => {\n    return memo(() => {\n      register(value);\n      return resolve(children);\n    });\n  };\n  const register = (value) => {\n    context(symbol, value);\n  };\n  const Context = { Provider, register };\n  CONTEXTS_DATA.set(Context, { symbol, defaultValue });\n  return Context;\n}\nconst createDirective = (name, fn, options) => {\n  const immediate = !!(options == null ? void 0 : options.immediate);\n  const data = { fn, immediate };\n  const symbol = SYMBOLS_DIRECTIVES[name] || (SYMBOLS_DIRECTIVES[name] = Symbol());\n  const Provider = ({ children }) => {\n    return memo(() => {\n      register();\n      return resolve(children);\n    });\n  };\n  const ref = (...args) => {\n    return (element) => {\n      fn(element, ...args);\n    };\n  };\n  const register = () => {\n    var _a;\n    (_a = DIRECTIVE_OUTSIDE_SUPER_ROOT).current || (_a.current = !owner().isSuperRoot);\n    context(symbol, data);\n  };\n  return { Provider, ref, register };\n};\nconst createDirective$1 = createDirective;\nvar n = function(t2, s, r, e) {\n  var u;\n  s[0] = 0;\n  for (var h = 1; h < s.length; h++) {\n    var p = s[h++], a = s[h] ? (s[0] |= p ? 1 : 2, r[s[h++]]) : s[++h];\n    3 === p ? e[0] = a : 4 === p ? e[1] = Object.assign(e[1] || {}, a) : 5 === p ? (e[1] = e[1] || {})[s[++h]] = a : 6 === p ? e[1][s[++h]] += a + \"\" : p ? (u = t2.apply(a, n(t2, a, r, [\"\", null])), e.push(u), a[0] ? s[0] |= 2 : (s[h - 2] = 0, s[h] = u)) : e.push(a);\n  }\n  return e;\n}, t = /* @__PURE__ */ new Map();\nfunction htm(s) {\n  var r = t.get(this);\n  return r || (r = /* @__PURE__ */ new Map(), t.set(this, r)), (r = n(this, r.get(s) || (r.set(s, r = function(n2) {\n    for (var t2, s2, r2 = 1, e = \"\", u = \"\", h = [0], p = function(n3) {\n      1 === r2 && (n3 || (e = e.replace(/^\\s*\\n\\s*|\\s*\\n\\s*$/g, \"\"))) ? h.push(0, n3, e) : 3 === r2 && (n3 || e) ? (h.push(3, n3, e), r2 = 2) : 2 === r2 && \"...\" === e && n3 ? h.push(4, n3, 0) : 2 === r2 && e && !n3 ? h.push(5, 0, true, e) : r2 >= 5 && ((e || !n3 && 5 === r2) && (h.push(r2, 0, e, s2), r2 = 6), n3 && (h.push(r2, n3, 0, s2), r2 = 6)), e = \"\";\n    }, a = 0; a < n2.length; a++) {\n      a && (1 === r2 && p(), p(a));\n      for (var l = 0; l < n2[a].length; l++)\n        t2 = n2[a][l], 1 === r2 ? \"<\" === t2 ? (p(), h = [h], r2 = 3) : e += t2 : 4 === r2 ? \"--\" === e && \">\" === t2 ? (r2 = 1, e = \"\") : e = t2 + e[0] : u ? t2 === u ? u = \"\" : e += t2 : '\"' === t2 || \"'\" === t2 ? u = t2 : \">\" === t2 ? (p(), r2 = 1) : r2 && (\"=\" === t2 ? (r2 = 5, s2 = e, e = \"\") : \"/\" === t2 && (r2 < 5 || \">\" === n2[a][l + 1]) ? (p(), 3 === r2 && (h = h[0]), r2 = h, (h = h[0]).push(2, 0, r2), r2 = 0) : \" \" === t2 || \"\t\" === t2 || \"\\n\" === t2 || \"\\r\" === t2 ? (p(), r2 = 2) : e += t2), 3 === r2 && \"!--\" === e && (r2 = 4, h = h[0]);\n    }\n    return p(), h;\n  }(s)), r), arguments, [])).length > 1 ? r : r[0];\n}\nexport {\n  ErrorBoundary$1 as E,\n  For$1 as F,\n  If$1 as I,\n  Suspense$1 as S,\n  Ternary$1 as T,\n  useResolved as a,\n  ForIndex$1 as b,\n  ForValue$1 as c,\n  Switch$1 as d,\n  useAbortController$1 as e,\n  useAbortSignal$1 as f,\n  useAnimationFrame$1 as g,\n  htm as h,\n  useAnimationLoop$1 as i,\n  useContext as j,\n  useEventListener as k,\n  useFetch$1 as l,\n  useIdleCallback$1 as m,\n  useIdleLoop$1 as n,\n  useInterval$1 as o,\n  usePromise$1 as p,\n  useTimeout$1 as q,\n  createContext as r,\n  createDirective$1 as s,\n  SuspenseContext$1 as t,\n  useResource$1 as u\n};\n//# sourceMappingURL=htm.module-aa8e56d7.js.map\n","import { m as setChild, a as createHTMLNode } from \"./setters-3e914440.js\";\nimport { n as root, g as get, d as boolean, h as effect, b as assign, _ as context, k as reaction, J as SYMBOL_SUSPENSE } from \"./use_microtask-e694cf95.js\";\nimport { t as SuspenseContext, S as Suspense } from \"./htm.module-aa8e56d7.js\";\nconst render = (child, parent) => {\n  if (!parent || !(parent instanceof HTMLElement))\n    throw new Error(\"Invalid parent node\");\n  parent.textContent = \"\";\n  return root((dispose) => {\n    setChild(parent, child);\n    return () => {\n      dispose();\n      parent.textContent = \"\";\n    };\n  });\n};\nconst render$1 = render;\nconst Portal = ({ when = true, mount, wrapper, children }) => {\n  const portal = get(wrapper) || createHTMLNode(\"div\");\n  if (!(portal instanceof HTMLElement))\n    throw new Error(\"Invalid wrapper node\");\n  const condition = boolean(get(when));\n  effect(() => {\n    if (!get(condition))\n      return null;\n    const parent = get(mount) || document.body;\n    if (!(parent instanceof Element))\n      throw new Error(\"Invalid mount node\");\n    parent.insertBefore(portal, null);\n    return () => {\n      parent.removeChild(portal);\n    };\n  });\n  effect(() => {\n    if (!get(condition))\n      return null;\n    return render$1(children, portal);\n  });\n  return assign(() => get(condition) || children, { metadata: { portal } });\n};\nconst Portal$1 = Portal;\nconst renderToString = (child) => {\n  return new Promise((resolve) => {\n    root((dispose) => {\n      context(SYMBOL_SUSPENSE, void 0);\n      const suspense = SuspenseContext.new();\n      const { portal } = Portal$1({ children: Suspense({ children: child }) }).metadata;\n      reaction(() => {\n        if (suspense.active())\n          return;\n        resolve(portal.innerHTML);\n        dispose();\n      });\n    });\n  });\n};\nconst renderToString$1 = renderToString;\nexport {\n  Portal$1 as P,\n  renderToString$1 as a,\n  render$1 as r\n};\n//# sourceMappingURL=render_to_string-0e4682a5.js.map\n","var _a, _b;\nimport { E } from \"./jsx-db47810e.js\";\nimport { m as memo, r as resolve, g as get, i as isPrimitive, a as isFunction, S as SYMBOL_CLONE, b as assign, o as once, c as isObject } from \"./use_microtask-e694cf95.js\";\nimport { p, q, t, v, w, x, y, d, e, f, h, j, u, k, l, n, s } from \"./use_microtask-e694cf95.js\";\nimport { h as htm, u as useResource, a as useResolved } from \"./htm.module-aa8e56d7.js\";\nimport { E as E2, F, b, c, I, S, d as d2, T, r, s as s2, e as e2, f as f2, g, i, j as j2, k as k2, l as l2, m, n as n2, o, p as p2, q as q2 } from \"./htm.module-aa8e56d7.js\";\nimport { c as creatElement } from \"./jsx-runtime-742b912a.js\";\nimport { j as j3, a, j as j4 } from \"./jsx-runtime-742b912a.js\";\nimport { w as wrapCloneElement } from \"./wrap_clone_element-e197fd42.js\";\nimport { F as F2 } from \"./wrap_clone_element-e197fd42.js\";\nimport { P, r as r2, a as a2 } from \"./render_to_string-0e4682a5.js\";\nimport { t as t2 } from \"./template-53c731b3.js\";\nimport \"./setters-3e914440.js\";\nconst IS_BROWSER = !!((_b = (_a = globalThis.CDATASection) == null ? void 0 : _a.toString) == null ? void 0 : _b.call(_a).match(/^\\s*function\\s+CDATASection\\s*\\(\\s*\\)\\s*\\{\\s*\\[native code\\]\\s*\\}\\s*$/));\nconst isServer = () => {\n  return !IS_BROWSER;\n};\nconst isServer$1 = isServer;\nconst Dynamic = ({\n  component,\n  props\n  /* , children */\n}) => {\n  return memo(() => {\n    return resolve(creatElement(\n      get(component, false),\n      get(props)\n      /* , children */\n    ));\n  });\n};\nconst Dynamic$1 = Dynamic;\nconst cloneElement = (element, props) => {\n  if (isPrimitive(element))\n    return element;\n  else if (isFunction(element)) {\n    if (!element[SYMBOL_CLONE])\n      throw new Error(\"target is not cloneable, it is not created by jsx.createElement\");\n    const { component, props: oldProps } = element[SYMBOL_CLONE];\n    const newProps = { ...oldProps, props };\n    return wrapCloneElement(creatElement(component, newProps), component, newProps);\n  } else if (Array.isArray(element))\n    return element.map((e3) => cloneElement(e3, props));\n  else if (element.cloneNode)\n    return element.cloneNode();\n  throw new Error(\"Unknown element\");\n};\nconst cloneElement$1 = cloneElement;\nfunction h$1(component, props, key, isStatic, source, self) {\n  return creatElement(component, props);\n}\nconst registry = {};\nconst h2 = (type, props, key, isStatic, source, self) => creatElement(registry[type] || type, props);\nconst register = (components) => void assign(registry, components);\nconst html = assign(htm.bind(h2), { register });\nconst html$1 = html;\nconst lazy = (fetcher) => {\n  const fetcherOnce = once(fetcher);\n  const component = (props) => {\n    const resource = useResource(fetcherOnce);\n    return memo(() => {\n      return useResolved(resource, ({ pending, error, value }) => {\n        if (pending)\n          return;\n        if (error)\n          throw error;\n        const component2 = \"default\" in value ? value.default : value;\n        return resolve(creatElement(component2, props));\n      });\n    });\n  };\n  component.preload = () => {\n    return new Promise((resolve2, reject) => {\n      const resource = useResource(fetcherOnce);\n      useResolved(resource, ({ pending, error }) => {\n        if (pending)\n          return;\n        if (error)\n          return reject(error);\n        return resolve2();\n      });\n    });\n  };\n  return component;\n};\nconst lazy$1 = lazy;\nfunction mergeStyles(style = {}, css = \"\") {\n  const re = /([^:;]+)\\s*:\\s*([^;(]+(?:\\(.*?\\))?);?/igm;\n  const genObj = (css2 = \"\") => {\n    let match;\n    if (isObject(css2))\n      return css2;\n    else {\n      const style2 = {};\n      while (match = re.exec(css2)) {\n        const [, property, value] = match;\n        const trimmedProperty = property.trim();\n        const trimmedValue = value.trim();\n        style2[trimmedProperty] = trimmedValue;\n      }\n      return style2;\n    }\n  };\n  const sty = genObj(style);\n  return Object.assign(sty, genObj(css));\n}\nexport {\n  p as $,\n  get as $$,\n  Dynamic$1 as Dynamic,\n  E as Element,\n  E2 as ErrorBoundary,\n  F as For,\n  b as ForIndex,\n  c as ForValue,\n  F2 as Fragment,\n  I as If,\n  P as Portal,\n  S as Suspense,\n  d2 as Switch,\n  T as Ternary,\n  q as batch,\n  cloneElement$1 as cloneElement,\n  r as createContext,\n  s2 as createDirective,\n  creatElement as createElement,\n  h$1 as h,\n  html$1 as html,\n  t as isBatching,\n  v as isObservable,\n  isServer$1 as isServer,\n  w as isStore,\n  j3 as jsx,\n  a as jsxDEV,\n  j4 as jsxs,\n  lazy$1 as lazy,\n  mergeStyles,\n  r2 as render,\n  a2 as renderToString,\n  resolve,\n  x as store,\n  t2 as template,\n  y as untrack,\n  e2 as useAbortController,\n  f2 as useAbortSignal,\n  g as useAnimationFrame,\n  i as useAnimationLoop,\n  d as useBoolean,\n  e as useCleanup,\n  j2 as useContext,\n  f as useDisposed,\n  h as useEffect,\n  j as useError,\n  k2 as useEventListener,\n  l2 as useFetch,\n  m as useIdleCallback,\n  n2 as useIdleLoop,\n  o as useInterval,\n  memo as useMemo,\n  u as useMicrotask,\n  p2 as usePromise,\n  k as useReaction,\n  l as useReadonly,\n  useResolved,\n  useResource,\n  n as useRoot,\n  s as useSelector,\n  q2 as useTimeout,\n  wrapCloneElement\n};\n//# sourceMappingURL=index.es.js.map\n","import * as utils from './utils'\r\nimport { $, $$, Observable, ObservableReadonly, isObservable, store, useEffect, useMemo } from 'voby'\r\n\r\nexport type OptionType = {\r\n    rows: ObservableMaybe<number>\r\n    rowHeight: ObservableMaybe<number>\r\n    width: string | number | ObservableReadonly<string | number>\r\n    value: Observable<string | Data>\r\n    adjustTime?: ObservableMaybe<number>\r\n    momentumThresholdTime?: ObservableMaybe<number>\r\n    bounceTime?: ObservableMaybe<number>\r\n    momentumThresholdDistance?: ObservableMaybe<number>\r\n    resetSelectedOnDataChanged?: ObservableMaybe<boolean>\r\n\r\n    data: Observable<Data[]> | Observable<string[]>\r\n    isTransition?: boolean\r\n    isTouching?: boolean\r\n    easings?: {\r\n        scroll: number | string // easeOutQuint\r\n        scrollBounce: number | string // easeOutQuard\r\n        bounce: number | string // easeOutQuart\r\n    }\r\n}\r\n\r\nexport type Data = {\r\n    value: number | string,\r\n    disabled?: boolean,\r\n    text: string\r\n}\r\n\r\nexport type ItemType = { classList: any }\r\n\r\nconst isTouch = (e: TouchEvent | MouseEvent): e is TouchEvent =>\r\n    !!(e as TouchEvent).touches\r\n\r\nexport const Wheel = (props: OptionType) => {\r\n    const {\r\n        data, rowHeight = 34, adjustTime = 400, bounceTime = 600, momentumThresholdTime = 300, momentumThresholdDistance = 10,\r\n        value, resetSelectedOnDataChanged = false, width\r\n    } = props\r\n    let { rows = 5 } = props\r\n\r\n    const _items = $<Data[]>([])\r\n    const list = $<(() => HTMLLinkElement)[]>([])\r\n    const y = $(0)\r\n    const selectedIndex = $(0)\r\n    const isTransition = $(false)\r\n    const isTouching = $(false)\r\n    const easings = $<{\r\n        scroll: number | string // easeOutQuint\r\n        scrollBounce: number | string // easeOutQuard\r\n        bounce: number | string // easeOutQuart\r\n    }>({\r\n        scroll: \"cubic-bezier(0.23, 1, 0.32, 1)\", // easeOutQuint\r\n        scrollBounce: \"cubic-bezier(0.25, 0.46, 0.45, 0.94)\", // easeOutQuard\r\n        bounce: \"cubic-bezier(0.165, 0.84, 0.44, 1)\" // easeOutQuart\r\n    })\r\n\r\n    const transformName = $(utils.prefixed(\"transform\"))\r\n    const transitionName = $(utils.prefixed(\"transition\"))\r\n\r\n    const wheel = $<HTMLDivElement>()\r\n    const scroller = $<HTMLUListElement>()\r\n    const wheelHeight = useMemo(() => wheel()?.offsetHeight)\r\n    const maxScrollY = $<number>()\r\n    const startY = $<number>()\r\n    const lastY = $<any>()\r\n    const startTime = $<number>()\r\n\r\n    useEffect(() => {\r\n        data() // deps \r\n        if ($$(resetSelectedOnDataChanged))\r\n            selectedIndex(0)\r\n    })\r\n    useEffect(() => {\r\n        if ($$(rows) % 2 === 0) isObservable(rows) ? rows(r => ++r) : (rows as number)++\r\n    })\r\n\r\n    const _momentum = (current: number, start: number, time: number, lowerMargin: number, wheelSize: number, deceleration: number, rowHeight: number) => {\r\n        let distance = current - start\r\n        let speed = Math.abs(distance) / time\r\n        let destination\r\n        let duration\r\n\r\n        deceleration = deceleration === undefined ? 0.0006 : deceleration\r\n\r\n        destination = current + (speed * speed) / (2 * deceleration) * (distance < 0 ? -1 : 1)\r\n        duration = speed / deceleration\r\n\r\n        destination = Math.round(destination / rowHeight) * rowHeight\r\n\r\n        if (destination < lowerMargin) {\r\n            destination = wheelSize ? lowerMargin - (wheelSize / 2.5 * (speed / 8)) : lowerMargin\r\n            distance = Math.abs(destination - current)\r\n            duration = distance / speed\r\n        } else if (destination > 0) {\r\n            destination = wheelSize ? wheelSize / 2.5 * (speed / 8) : 0\r\n            distance = Math.abs(current) + destination\r\n            duration = distance / speed\r\n        }\r\n\r\n        return {\r\n            destination: Math.round(destination),\r\n            duration: duration\r\n        }\r\n    }\r\n\r\n    const _resetPosition = (duration: number) => {\r\n        let yy = y()\r\n\r\n        duration = duration || 0\r\n\r\n        if (yy > 0) yy = 0\r\n        if (yy < maxScrollY()) yy = maxScrollY()\r\n\r\n        if (yy === y()) return false\r\n\r\n        _scrollTo(yy, duration, easings().bounce)\r\n\r\n        return true\r\n    }\r\n\r\n    const _getClosestSelectablePosition = (y: number) => {\r\n        let index = Math.abs(Math.round(y / $$(rowHeight)))\r\n\r\n        const items = _items()\r\n        if (!items[index]?.disabled) return y\r\n\r\n        let max = Math.max(index, items.length - index)\r\n        for (let i = 1; i <= max; i++) {\r\n            if (!items[index + i].disabled) {\r\n                index += i\r\n                break\r\n            }\r\n            if (!items[index - i].disabled) {\r\n                index -= i\r\n                break\r\n            }\r\n        }\r\n        return index * -$$(rowHeight)\r\n    }\r\n\r\n    const _scrollTo = (yy: number, duration: number, easing: number | string) => {\r\n        if (y() === yy) {\r\n            _scrollFinish()\r\n            return false\r\n        }\r\n\r\n        y(_getClosestSelectablePosition(yy))\r\n\r\n        if (duration && duration > 0) {\r\n            isTransition(true)\r\n            scroller().style[transitionName()] = duration + \"ms \" + easing\r\n        } else {\r\n            _scrollFinish()\r\n        }\r\n    }\r\n\r\n    const _scrollFinish = () => {\r\n        let newIndex = Math.abs(y() / $$(rowHeight))\r\n        if (selectedIndex() != newIndex) {\r\n            selectedIndex(newIndex)\r\n\r\n            const v = _items()[selectedIndex()]\r\n            value(v)\r\n        }\r\n    }\r\n\r\n    useEffect(() => {\r\n        const v = (value() as Data)?.value ?? value() as string\r\n        const i = data().findIndex((vv, i) => (vv as Data).value === v || vv === v)\r\n        selectedIndex(i)\r\n    })\r\n\r\n    const _getCurrentY = () => {\r\n        const matrixValues = utils.getStyle(scroller(), transformName()).match(/-?\\d+(\\.\\d+)?/g) as string[]\r\n        return parseInt(matrixValues[matrixValues.length - 1])\r\n    }\r\n\r\n    const _start = (event: TouchEvent | MouseEvent) => {\r\n        event.preventDefault()\r\n\r\n        const items = _items()\r\n\r\n        if (!items.length) return\r\n\r\n        if (isTransition()) {\r\n            isTransition(false)\r\n            y(_getCurrentY())\r\n            scroller().style[transitionName()] = \"\"\r\n        }\r\n\r\n        startY(y())\r\n        lastY(isTouch(event) ? event.touches[0].pageY : event.pageY)\r\n        startTime(Date.now())\r\n\r\n        isTouching(true)\r\n    }\r\n\r\n    const _move = (event: TouchEvent | MouseEvent) => {\r\n        if (!isTouching()) return false\r\n\r\n        let yy = isTouch(event) ? event.changedTouches[0].pageY : event.pageY\r\n        let deltaY = yy - lastY()\r\n        let targetY = y() + deltaY\r\n        let now = Date.now()\r\n\r\n        lastY(yy)\r\n\r\n        if (targetY > 0 || targetY < maxScrollY()) {\r\n            targetY = y() + deltaY / 3\r\n        }\r\n\r\n        y(Math.round(targetY))\r\n\r\n        if (now - startTime() > $$(momentumThresholdTime)) {\r\n            startTime(now)\r\n            startY(y())\r\n        }\r\n\r\n        return false\r\n    }\r\n\r\n    const _end = (event: MouseEvent | TouchEvent) => {\r\n        if (!isTouching()) return false\r\n\r\n        const deltaTime = Date.now() - startTime()\r\n        let duration = $$(adjustTime)\r\n        let easing = easings().scroll\r\n        const distanceY = Math.abs(y() - startY())\r\n        let momentumVals\r\n        let yy\r\n\r\n        isTouching(false)\r\n\r\n        if (deltaTime < $$(momentumThresholdTime) && distanceY <= 10 && (event.target as HTMLDivElement)?.classList.contains(\"wheelpicker-item\")) {\r\n            const aid = +(event.target as HTMLLinkElement)?.getAttribute('_wsidx')\r\n\r\n            console.log(aid, -$$(rowHeight), duration, easing)\r\n            _scrollTo(aid * -$$(rowHeight), duration, easing)\r\n            return false\r\n        }\r\n\r\n        if (_resetPosition($$(bounceTime))) return\r\n\r\n        if (deltaTime < $$(momentumThresholdTime) && distanceY > $$(momentumThresholdDistance)) {\r\n            momentumVals = _momentum(y(), startY(), deltaTime, maxScrollY(), wheelHeight(), 0.0007, $$(rowHeight))\r\n            yy = momentumVals.destination\r\n            duration = momentumVals.duration\r\n        } else {\r\n            yy = Math.round(y() / $$(rowHeight)) * $$(rowHeight)\r\n        }\r\n\r\n        if (yy > 0 || yy < maxScrollY()) {\r\n            easing = easings().scrollBounce\r\n        }\r\n\r\n        _scrollTo(yy, duration, easing)\r\n    }\r\n\r\n    const _transitionEnd = () => {\r\n        isTransition(false)\r\n        scroller().style[transitionName()] = \"\"\r\n\r\n        if (!_resetPosition($$(bounceTime))) _scrollFinish()\r\n    }\r\n\r\n    useEffect(() => {\r\n\r\n        const dt = data()\r\n        const lis = []\r\n        const items = []\r\n\r\n        console.log('build data', dt)\r\n\r\n        items.push(...dt.map((item, idx) => {\r\n            item = typeof item === \"object\" ? item : {\r\n                text: item,\r\n                value: item\r\n            }\r\n\r\n            let li = () => <li class={['wheelpicker-item', {\r\n                //@ts-ignore\r\n                \"wheelpicker-item-disabled\": item.disabled,\r\n                \"wheelpicker-item-selected\": () => idx === selectedIndex()\r\n            }]}\r\n                //@ts-ignore\r\n                _wsidx={idx}>\r\n                {(item as Data).text ?? item}\r\n            </li>\r\n\r\n\r\n            lis.push(li)\r\n            return item\r\n        }))\r\n\r\n        list(lis)\r\n        _items(items)\r\n\r\n\r\n        y(selectedIndex() * -$$(rowHeight))\r\n\r\n        maxScrollY(-$$(rowHeight) * (dt.length - 1))\r\n\r\n        value(items[selectedIndex()])\r\n    })\r\n\r\n\r\n    const _wheel = () => {\r\n        let pid: number\r\n        let pwid: number\r\n        wheel().onwheel = event => {\r\n            let duration = $$(adjustTime)\r\n            let easing = easings().scroll\r\n\r\n            if (!event.target)\r\n                return\r\n\r\n            const aid = +(event.target as HTMLLinkElement)?.getAttribute('_wsidx')\r\n\r\n            _scrollTo((pid = ((aid === pwid ? pid : aid) + Math.sign(event.deltaY))) * -$$(rowHeight), duration, easing)\r\n\r\n            pwid = aid\r\n        }\r\n    }\r\n\r\n    return <div ref={wheel} class='wheelpicker-wheel' style={{ height: $$(rowHeight) * $$(rows) + \"px\", width }}\r\n        onTouchStart={_start} onTouchMove={_move} onTouchEnd={_end} onTouchCancel={_end}\r\n        onMouseDown={_start} onMouseMove={_move} onMouseUp={_end} onMouseLeave={_end}\r\n        onWheel={_wheel}\r\n    >\r\n        <ul ref={scroller} class='wheelpicker-wheel-scroller' style={{ transform: () => \"translate3d(0,\" + y() + \"px,0)\", marginTop: $$(rowHeight) * Math.floor($$(rows) / 2) + \"px\" }} onTransitionEnd={_transitionEnd}>\r\n            {list}\r\n        </ul>\r\n    </div>\r\n}\r\n","\"use strict\"\r\n\r\nimport './WheelPicker.scss'\r\n\r\nimport { Wheel, Data } from './Wheel'\r\nimport { $, $$, isObservable, Observable, useEffect, useMemo, batch } from 'voby'\r\n\r\n\r\nexport type OptionType = {\r\n    title?: ObservableMaybe<Child>\r\n    rows?: ObservableMaybe<number>\r\n    rowHeight?: ObservableMaybe<number>\r\n    data?: (Observable<string[]> | Observable<Data[]>)[]\r\n    hideOnBackdrop?: ObservableMaybe<boolean>\r\n    disabled?: ObservableMaybe<boolean>\r\n    hidden?: ObservableMaybe<boolean>\r\n    onShow?: () => void\r\n    onCancel?: () => void\r\n    value: Observable<string | Data>[]\r\n    tempValue: Observable<string | Data>[]\r\n    resetSelectedOnDataChanged?: ObservableMaybe<boolean>\r\n}\r\n\r\nexport const WheelPicker = (props: OptionType) => {\r\n    const { data, rows = 5, rowHeight = 34,\r\n        onCancel, onShow, disabled, hidden,\r\n        value, tempValue, title, hideOnBackdrop, resetSelectedOnDataChanged\r\n    } = props\r\n\r\n    const control = $<HTMLInputElement>()\r\n    const closed = $<boolean>(true)\r\n\r\n    const container = $<HTMLDivElement>()\r\n    const restore = $<boolean>()\r\n    const cancelled = $<boolean>()\r\n    const oriValue = value.map(v => v())\r\n\r\n    useEffect(() => {\r\n        if (!Array.isArray(value))\r\n            console.error('value must be array.')\r\n\r\n        if (!Array.isArray(tempValue))\r\n            console.error('tempValue must be array.')\r\n\r\n        const d = data\r\n        if (!Array.isArray(value) || d.length !== value.length)\r\n            throw new Error('value & data not in same dimension')\r\n\r\n        if (!Array.isArray(tempValue) || d.length !== tempValue.length)\r\n            throw new Error('tempValue & data not in same dimension')\r\n\r\n        d.forEach((dd, i) => {\r\n            if (!value[i]) value[i] = $(d[i]()[0])\r\n            if (!value[i]()) value[i](d[i]()[0])\r\n            tempValue[i](value[i]())\r\n        })\r\n    })\r\n\r\n    data.forEach((_, i) => {\r\n        oriValue[i] = value[i]()\r\n    })\r\n\r\n    const shown = $(false)\r\n\r\n    const _onFocus = (event: FocusEvent) => {\r\n        (event.target as HTMLDivElement).blur()\r\n        show()\r\n    }\r\n\r\n    const _backdropTransEnd = () => {\r\n        if (!shown()) {\r\n            container().style.display = \"none\"\r\n            closed(true)\r\n        }\r\n    }\r\n\r\n    const _set = (silent?: boolean) => {\r\n        cancelled(false)\r\n        if (silent === true) return\r\n\r\n        batch(() => value.forEach((v, i) => oriValue[i] = v(tempValue[i]())))\r\n\r\n        shown(false)\r\n    }\r\n\r\n    useEffect(() => {\r\n        if (restore())\r\n            batch(() => {\r\n                tempValue.forEach((v, i) => v(oriValue[i]))\r\n                value.forEach((v, i) => v(oriValue[i]))\r\n            })\r\n    })\r\n\r\n    const _cancel = () => {\r\n        cancelled(restore(true))\r\n\r\n        batch(() => tempValue.forEach((v, i) => v(value[i]())))\r\n\r\n        onCancel?.()\r\n        shown(false)\r\n    }\r\n\r\n    const show = () => {\r\n        if ($$(disabled) || !closed()) return\r\n\r\n        let cont = container()\r\n\r\n        closed(restore(false))\r\n\r\n        cont.style.display = \"block\"\r\n        shown(true)\r\n\r\n        onShow?.()\r\n    }\r\n\r\n    const width = useMemo(() => (100 / data.filter(f => !!f()).length) + '%')\r\n    const ws = useMemo(() => data.map((v, i) => <Wheel\r\n        rows={rows}\r\n        rowHeight={rowHeight}\r\n        width={width}\r\n        data={v}\r\n        resetSelectedOnDataChanged={resetSelectedOnDataChanged}\r\n        value={tempValue[i]}\r\n    />))\r\n\r\n    const height = $$(rowHeight) * Math.floor($$(rows) / 2) - 1 + \"px\"\r\n\r\n    return <div readOnly className={['wheelpicker-control'/* , {'wheelpicker-hiddeninput':hiddenInput} */]} /* type={hiddenInput?'hidden':null} */ onFocus={_onFocus} onClick={_onFocus}>\r\n        {control() ?? <input type='text' disabled={disabled} hidden={hidden} value={() => tempValue.map(v => (v() as Data)?.value ?? v()) as any}></input>}\r\n        <div ref={container} className=\"wheelpicker\" class={[{ 'shown': shown }]} /* style={{ display: () => shown() ? 'block' : 'none' }} */>\r\n            <div class='wheelpicker-backdrop' onTransitionEnd={_backdropTransEnd} onClick={$$(hideOnBackdrop) ? _cancel : null}></div>\r\n            <div class='wheelpicker-panel'>\r\n                <div class='wheelpicker-actions'>\r\n                    <button type='button' class='btn-cancel' onClick={_cancel}>取消</button>\r\n                    <button type='button' class='btn-set' onClick={() => _set()}>确定</button>\r\n                    <h4 class='wheelpicker-title'>{$$(title)}</h4>\r\n                </div>\r\n                <div class='wheelpicker-main'>\r\n                    <div class='wheelpicker-wheels'>\r\n                        {ws}\r\n                    </div>\r\n                    <div class='wheelpicker-mask wheelpicker-mask-top' style={{ height }}></div>\r\n                    <div class='wheelpicker-mask wheelpicker-mask-current'></div>\r\n                    <div class='wheelpicker-mask wheelpicker-mask-btm' style={{ height }} ></div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n}\r\n\r\n","import { WheelPicker as WheelPickerV } from \"./src/WheelPicker\"\r\nimport { $, render, useEffect } from 'voby'\r\nimport data from './data.json'\r\nimport { Data } from \"src/Wheel\"\r\n\r\nconst fruits = [$(\"西瓜,柠檬,草莓,荔枝,橘子,菠萝,香蕉,柚子,苹果,龙眼\".split(\",\"))]\r\nconst frutisEn = \"watermelon,lemon,strawberry,litchi,orange,pineapple,banana,grapefruit,apple,longan\".split(\",\")\r\nconst frutiData = $(fruits[0]().map((name, idx) => ({\r\n    text: name,\r\n    value: frutisEn[idx]\r\n})))\r\n\r\nconst vegetables = \"香菜,青菜,芦笋,萝卜,水芹,黄瓜,冬瓜,番茄,茄子,土豆\".split(\",\")\r\nconst vegetablesEn = \"parsley,celery,asparagus,carrot,celery,cucumber,melon,tomato,eggplant,potato\".split(\",\")\r\nconst vegetableData = $(vegetables.map((name, idx) => ({\r\n    text: name,\r\n    value: vegetablesEn[idx]\r\n})))\r\n\r\nconst mv = [$(\"lemon\") as any, $(\"carrot\")]\r\nconst mtv = [$() as any, $()]\r\n\r\n\r\nlet defaultProv = Object.keys(data)[0]\r\nconst keys = Object.keys(data)\r\n\r\nObject.keys(data).forEach(k => {\r\n    keys[k] = Object.keys(data[k])\r\n    Object.keys(data[k]).forEach(kk => {\r\n        keys[k][kk] = data[k][kk]\r\n    })\r\n})\r\n\r\nconst sv = [$('草莓')]\r\nconst stv = [$()]\r\nuseEffect(() => console.log('Single changed', sv[0]()))\r\nuseEffect(() => console.log('Multiple changed', mv[0](), mv[1]()))\r\n\r\nconst dt = [\r\n    $(Object.keys(data)), //state\r\n    $(keys[defaultProv]), //Object.keys(data[defaultProv]), //city\r\n    $(keys[defaultProv][keys[defaultProv][0]])//data[defaultProv][Object.keys(data[defaultProv])[0]] //district\r\n] as const\r\nconst dv = [$<string | Data>(), $<string | Data>(), $<string | Data>()]\r\nconst tempValue = [$<string | Data>(), $<string | Data>(), $<string | Data>()]\r\n\r\nconst empty = []\r\n\r\nuseEffect(() => { console.log('tempValue', tempValue[0](), tempValue[1](), tempValue[2]()) })\r\nuseEffect(() => { console.log('dv', dv[0](), dv[1](), dv[2]()) })\r\n\r\nrender(<div>\r\n    <h1>WheelPicker</h1>\r\n    <p>仿 iOS UIPickerView 的滚动选择器</p>\r\n    <h3>单列</h3>\r\n\r\n    <WheelPickerV\r\n        title={< h1 > 单列选择器 < button onClick={e => stv[0]('香蕉')} > 香蕉</button ></h1 >}\r\n        data={fruits}\r\n        value={sv as any}\r\n        tempValue={stv as any}\r\n        rows={6}\r\n        hideOnBackdrop\r\n    />\r\n\r\n    <h3><label for=\"demo2\">两列带默认值</label></h3>\r\n    <WheelPickerV\r\n        data={[frutiData, vegetableData]}\r\n        value={mv}\r\n        tempValue={mtv}\r\n    />\r\n\r\n    <h3><label for=\"demo3\">城市联动</label></h3>\r\n    <WheelPickerV hideOnBackdrop\r\n        data={dt as any}\r\n        value={dv}\r\n        tempValue={tempValue}\r\n        resetSelectedOnDataChanged\r\n\r\n        onShow={() => {\r\n            console.log(\"onShow\")\r\n        }}\r\n        onCancel={() => {\r\n            console.log(\"onCancel\")\r\n        }}\r\n        formatValue={value => {\r\n            return value.join(\" \")\r\n        }}\r\n    />\r\n\r\n</div >, document.getElementById('voby'))\r\n\r\nuseEffect(() => {\r\n    let l1 = keys[(tempValue[0]() as Data)?.value ?? tempValue[0]() as string] ?? empty\r\n    if (!((tempValue[1]() as Data)?.value ?? tempValue[1]() as string))\r\n        tempValue[1](l1[0])\r\n\r\n    let l2 = l1[(tempValue[1]() as Data)?.value ?? tempValue[1]() as string] ?? empty\r\n    const d = dt\r\n    if (d[1]() !== l1 || d[2]() !== l2)\r\n        if (d[1]() !== l1 || d[2]() !== l2) {\r\n            d[1](l1)\r\n            if (d[2] !== l2)\r\n                d[2](l2)\r\n\r\n            const i1 = d[1]().indexOf((tempValue[1]() as Data)?.value ?? tempValue[1]() as string) === -1\r\n            const i2 = d[2]().indexOf((tempValue[2]() as Data)?.value ?? tempValue[2]() as string) === -1\r\n\r\n            if (i1 || i2) {\r\n                dv[0](tempValue[0]())\r\n                if (i1)\r\n                    dv[1](tempValue[1](d[1]()[0]))\r\n\r\n                if (i2)\r\n                    dv[2](tempValue[2](d[2]()[0]))\r\n            }\r\n        }\r\n})\r\n"],"names":["target","_a","_b","_a2","keys","observable","data","useMicrotask","wrapElement","isSVG","$","utils.prefixed","useMemo","useEffect","$$","start","rowHeight","y","max","i","utils.getStyle","dt","tempValue","jsxs","render","WheelPickerV"],"mappings":"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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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"}